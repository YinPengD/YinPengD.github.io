<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从源码剖析虚幻引擎编译原理]]></title>
    <url>%2F2019%2F08%2F13%2F%E4%BB%8E%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[网上UE4对于虚幻引擎的编译系统的理解大多是从UBT或是UHT的引擎构建工具单独的角度进行了解的，而这篇文章从虚幻引擎编译系统整体的角度，通过源码剖析的方式去详细的了解了虚幻引擎的整个编译系统。 1.解决方案工程的生成我们点击右键UE4工程，点击Generate visual studio project 将会生成用于Visual studio进行调试的工程文件MyProject.sln,这一过程发生了什么其中的原理又是什么呢？ Generate visual studio project 的实质点击右键 并选择 生成Visual Studio文件的这个右键其实对应的就是执行UnrealBuildTool.exe的带参命令，” “引起来的中间部分是你虚幻项目文件的路径 1Running C:/Program Files/Epic Games/UE_4.15/Engine/Binaries/DotNET/UnrealBuildTool.exe -projectfiles -project=&quot;C:/UnrealEngine4Project/GJM_Flying/GJM_Flying.uproject&quot; -game -rocket -progress 如果你的UE4是复制于其他电脑的，你右键UE4工程就会没有生成Visual Studio这个选项，那么这个你可以使用这个命令去手动的生成.sln工程 调用UnrelBuildTool做了些什么？UnrealBuildTool扫描了解决方案目录中的模块,插件和源文件，更新项目文件和解决方案，还包括生成Intellisense数据（光标悬停在函数上时显示类定义和注释技术的数据) 这也就是为什么当我们们在vs中添加了C++类没有用和添加第三方类没有用的原因，想要在本地添加类中就要删除Intermediate文件夹后重新生成.sln工程文件 在这个过程中创建了2个目录.vs文件夹和.Intermediate文件夹 .vs文件夹主要用来存储当前用户在解决方案中的工作配置，具体包括VS关闭前最后的窗口布局、最后打开的选项卡/操作记录/文件文档、某些自定义配置/开发环境、调试断点等这类设置信息和状态。这样每当用户关闭解决方案后再重新打开，就能继续之前的工作状态 .Intermediate文件夹主要初始化了一些马上要用的空文件夹，和在/Build/BuileRules文件夹下的UBT扫描模块时生成的地址（.txt)，动态库(.dll)，pdb(调试信息文件);还在ProjectFiles文件夹中生成了一些UE4和项目的工程配置文件。 涉及到的文件说明 sln是解决方案的配置，主要是管理这个方案里的多个vcxproj vcxproj是工程的配置文件，管理工程中细节比如包含的文件，引用库等 一般没有sln，也可以直接打开vcxproj，也可以重新生成sln，sln里有多个工程，当你移除某个工程时sln会有变化 vcxproj.filters文件是过滤信息文件，解决方案中的筛选器文件就保存在此文件中， 故一般我也将该文件添加到版本控制中， vcxproj.user是本地化用户配置，允许多个用户使用自己喜好的方式配置这个项目（例如打开项目时候窗体位置等与项目内容无关的配置） .suo（Solution User Opertion）：解决方案用户选项记录所有将与解决方案建立关联的选项，以便在每次打开时，它都包含您所做的自定义设置。比如VS布局,项目最后编译的而又没有关掉的文件(下次打开时用)。 .PDB文件，程序数据库文件,它存储了被编译文件的调试信息 开始调试准确的生成了工程文件后，我们就可以在VS中对你的项目生成解决方案，也就是编译你的代码，我们来从编译输出的日志文件来了解UE4的整个编译过程。 这是一个用模板生成的项目，一个最简单的编译过程输出的日志 配置信息编译器在开始工作之前，需要知道当前的系统环境，比如标准库在哪里、软件的安装位置在哪里、需要安装哪些组件等等。这是因为不同计算机的系统环境不一样，通过指定编译参数，编译器就可以灵活适应环境，编译出各种环境都能运行的机器码。这个确定编译参数的步骤，就叫做”配置”（configure）。 用文档编辑软件打开sln文件就可以看到这些配置信息了，我列举了一些其中配置信息： 编译器版本信息 文件生成位置 依赖模块库位置 确定依赖关系编译器需要确定编译的先后顺序，因为源码文件之间往往存在依赖关系，假定A文件依赖于B文件，编译器应该保证做到下面两点。 （1）只有在B文件编译完成后，才开始编译A文件。 （2）当B文件发生变化时，A文件会被重新编译。 编译顺序保存在一个叫做makefile的文件中，里面列出哪个文件先编译，哪个文件后编译。在GCC编译器中makefile文件由configure脚本运行生成，这就是为什么编译时configure必须首先运行的原因。在确定依赖关系的同时，编译器也确定了，编译时会用到哪些头文件。 当你点击项目-生成之后，VS会根据项目默认设置的构建生成命令行，去调用其中的批处理文件build.bat 我们来看看这个批处理文件具体做了什么？ 我们可以从上图得知，VS仅仅只是去调用了UBT就结束了 而然后接下来重大的任务就交给了UBT,接着我们来分析UBT做了些什么？ UBT-引擎构建工具UBT职能介绍 扫描解决方案目录中的模块和插件 确定需要重新构建的所有模块 调用UHT来解析c++头文件 从.Build.cs和.Target.cs创建编译器和链接器选项 执行特定于平台的编译器(VisualStudio, LLVM) UBT在这一阶段做的事的总结下来就算是收集信息，参数解析，生成makefile，调用UHT 收集信息，参数解析 生成makfile 调用UHT 这时红色方框处生成了一个.uhtmanifest文件，这个文件位于F:\UE4\Project\MyProject\Intermediate\Build\Win64\MyProjectEditor\Development 由上图内容可知这个我呢间保存了所有的模块编译路径，C++路径，预编译头路径 到此UBT的使命就结束了，它在编译原理所担负的任务是：确定库文件，头文件地址；生成makefile确定依赖关系，而在日志的输出中担负的是以下的任务 注意 我们编写的Target.cs , Buile.cs 都是为了方便UBT识别并处理模块的依赖而服务的 UBT是给UHT打工的，他们之间的关联靠一个.uhtmanifest文件 UHT-预编译预处理UHT主要职能介绍： 初始化Log系统 初始化文件系统 编译反射代码 UHT在这一阶段做的事的总结下来就算是与预初始化系统，解析生成反射代码 预初始化系统从UHT的入口函数我们可以看到这个初始化函数 引擎的入口函数也会使用这个函数去做主循环的初始化 初始化日志系统从初始化函数我们可以看到里面对日志系统进行了初始化，因为我们在编译中需要输出日志 初始化文件系统同理也初始化了文件系统 生成反射代码在开始生成反射代码之前，我们还有一项重要的事情要做，就是去获取.uhtmanifest文件，用于之后解析 接着就来到了我们的重头戏，来看看UHT是如何去解析C++代码，生成.generated.h和 .gen.cpp文件，实现反射机制的1.解析uhtmanifeest文件 读取所有源码的头文件并保存在GWarn中 对头文件进行解析 从上图可以看出分析解析头文件的模块，头文件，源文件，依赖文件 UENUM()、UCLASS()、USTRUCT()、UFUNCTION()、以及UPROPERTY()等宏都被被展开成C++代码，展开后就会生成Generated文件，其中的展开过程可以参考这篇博客，UHT编译 里面有详细的记录 生成generated文件 如果你使用了继承自UObject类的，那么你就会生成.generated.h文件，在编译中就会使用到这个文件所以得包含在内，而且.generated.h必须最后一个被包含，否则会报错，申明如下： 生成的generated文件有以下几种： .generated.cpp 一个工程只有一个，这个文件是用来为每个支持反射的类生成反射信息的代码，比如注册属性、添加源数据等。 .generated.dep.h 这个文件里面就是包含了上面.generated.cpp用到的头文件。 Classes.h 存放着预编译的宏 .generated.h 这个就是为每个支持反射的头文件生成的对应的宏的代码。 实际上ue4的反射就是UBT和UHT联手打造，UBT负责收集信息，UHT负责生成反射信息并注册，生成反射数据之后UHT的作用就基本结束了，接下来就交给VS编译了。 实际经历的过程： 编译 UHT生成成功之后，就会调用VS编译工具进行编译了，编译器对源代码进行编译，是一个将以文本形式存在的源代码翻译为机器语言形式的目标文件的过程。 分为两大步： 1.编译 ：把文本形式的源代码翻译成机器语言，并形成目标文件 2.连接 ：把目标文件 操作系统的启动代码和库文件组织起来形成可执行程序 LLVM—VisualStudio编译工具UE4实际编译过程 VS会创建很多个actions事件，具体有哪些呢？取出内联函数，模板函数，模板类，将其定义存放在inl文件中 主要为了避免头文件过长、版面混乱 调用登录时启动界面的图片资源（未验证） 编译所有的cpp文件（包含的Project.generated.cpp也在内)，并生成.obj的二进制文件 将.obj文件链接生成.lib静态库和.dll动态库 静态库会在链接程序（link.exe)在生成可执行文件拷贝到程序中，成为其中一部分，而动态链接所调用的函数代码并没有被拷贝到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息，在需要的时候才会调用。能够节省内存 至此，虚幻引擎的编译系统的探究就到此为止，如果有时间我我会把UHT是如何使用反射在网络通信的，是如何与蓝图交互的，在垃圾回收方面是发挥着什么样的作用。虚幻引擎的烘焙，部署，打包的底层原理都挺感兴趣，之后都会详细了解。 之所以这么详细的去了解是因为之前一直以来编译调试UE4，都是出现VS中报错了，然后去复制错误，然后谷歌，或者去猜错误的原因，对于其中出错的实质却不胜了解，而且对于报错中的信息也是一知半解，然后前几天在拍错的过程中看到的一个博客中看到了一句话令我印象深刻。 ”不要成为编译器的奴隶“ 所以有了这篇经过整理，实践，体会的文章，虽然没有深入到最底层，但是也有了大概的框架轮廓。参考文章： UBT的底层原理：https://imzlp.me/posts/6362/ 编译器的工作过程：http://www.ruanyifeng.com/blog/2014/11/compiler.html 虚幻4反射: https://www.cnblogs.com/ghl_carmack/p/5698438.html UE4反射宏展开： https://zhuanlan.zhihu.com/p/46836554 C++编译原理：http://www.ruanyifeng.com/blog/2014/11/compiler.html 书籍：《大象无形 虚幻引擎程序设计浅析》 对象模型和蓝图部分]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>编译原理</tag>
        <tag>源码</tag>
        <tag>UBT</tag>
        <tag>UHT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义类型插件的创建]]></title>
    <url>%2F2019%2F08%2F05%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8F%92%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[除了虚幻4官方为我们提供的几种创建插件的模板类型，我们还可以根据自己的需要来定制化一些插件类型，这里介绍的就是一种自定义资源类型的插件的创建方法。 基本的插件类型 Blank：原始的插件，只提供最基础的目录与文件创建，可以是任何内容插件。 Content Ony ：只能在Content目录的插件，通常是给美术资源之类做的插件。 Blueprint Library：蓝图库，如其名，就是一些比较独立蓝图库，封装好给不同游戏用，比如A星寻路算法 Editor Toolbar Button：创建一个在编辑器上面的按钮插件，创建在如下图位置。 Editor Standalone Window：独立窗体，创建一个独立界面的编辑器，通常和Slate搭配使用。 Editor Mode：创建一个在下面位置的插件 除了上面的官方自定义的插件类型，我还可以自定义一些其他的类型，我就来介绍一种自定义插件类型 自定义资源类型插件创建过程要在虚幻4创建一个自定义的编辑器资源类型，其中创建的过程： 声明资源类型的C++类 虚幻4中有很多的资源类型，例如材质，贴图，蓝图，数据，纹理等，我们可以根据自己的需要继承相对应资源的类 数据类123456789101112131415UCLASS()class CUSTOMASSET_API UMyDataAsset : public UDataAsset&#123; GENERATED_BODY() UPROPERTY(EditAnywhere, Category = &quot;MyDataAsset&quot;) FString StrProperty; UPROPERTY(EditAnywhere, Category = &quot;MyDataAsset&quot;) float NumProperty; UPROPERTY(EditAnywhere,meta = (DisplayName = &quot;IsActive?&quot;), Category = &quot;MyDataAsset&quot;) bool bIsActive; &#125;; 原始类123456789UCLASS()class MYTEST_API UMyObject : public UObject&#123; GENERATED_BODY() public: UPROPERTY(EditAnywhere) int A;&#125;; 实现资源创建工厂 即让用户可以创建这个资源的实例（让它出现在Content Browser） 1234567891011UCLASS()class GENERICGRAPHEDITOR_API UGenericGraphFactory : public UFactory&#123; GENERATED_BODY()public: UGenericGraphFactory(); virtual ~UGenericGraphFactory(); virtual UObject* FactoryCreateNew(UClass* Class, UObject* InParent, FName Name, EObjectFlags Flags, UObject* Context, FFeedbackContext* Warn) override;&#125;; 实现两个方法： 构造函数指定当前工厂类创建的实例是是什么类型 123456UGenericGraphFactory::UGenericGraphFactory()&#123; bCreateNew = true; bEditAfterNew = true; SupportedClass = UGenericGraph::StaticClass();&#125; 重载工厂类的创建函数 1234UObject* UGenericGraphFactory::FactoryCreateNew(UClass* Class, UObject* InParent, FName Name, EObjectFlags Flags, UObject* Context, FFeedbackContext* Warn)&#123; return NewObject&lt;UObject&gt;(InParent, Class, Name, Flags | RF_Transactional);&#125; 创建了工厂类之后，UE4就会自动去识别这个资源类了，但是这个资源类还有很多的细节没有实现。 注意：继承的Factory类是UnrealEd模块的，所以在.cs配置文件要添加UnreaEd模块 绑定资源响应事件 Asset文件需要绑定一个FAssetTypeActions_ClassTypeBase类, 作为一些基本操作的响应, 例如打开、合并和差异化比较等 创建Actions操作1234567891011121314151617181920212223242526272829303132333435363738class FAssetTypeActions_GenericGraph : public FAssetTypeActions_Base&#123;public: FAssetTypeActions_GenericGraph(EAssetTypeCategories::Type InAssetCategory); virtual FText GetName() const override; virtual FColor GetTypeColor() const override; virtual UClass* GetSupportedClass() const override; virtual void OpenAssetEditor(const TArray&lt;UObject*&gt;&amp; InObjects, TSharedPtr&lt;class IToolkitHost&gt; EditWithinLevelEditor = TSharedPtr&lt;IToolkitHost&gt;()) override; virtual uint32 GetCategories() override;private: EAssetTypeCategories::Type MyAssetCategory;&#125;;//////////////FText FMyObjectTypeAction::GetName() const&#123; return FText::FromString(&quot;MyObject&quot;);&#125; uint32 FMyObjectTypeAction::GetCategories()&#123; return MyCustomCategory;&#125; FColor FMyObjectTypeAction::GetTypeColor() const&#123; return FColor(255, 0, 0, 255);&#125; FText FMyObjectTypeAction::GetAssetDescription(const FAssetData&amp; AssetData) const&#123; return FText::FromString(&quot;MyObjectDes&quot;);&#125; UClass* FMyObjectTypeAction::GetSupportedClass() const&#123; return UMyObject::StaticClass(); 注册资源文件进行注册12345678910111213141516/* 模块开始时调用 */void FGenericGraphEditor::StartupModule()&#123; // 获取资产管理工具 IAssetTools&amp; AssetTools = FModuleManager::LoadModuleChecked&lt;FAssetToolsModule&gt;(&quot;AssetTools&quot;).Get(); // 初始化一种资源类型 GenericGraphAssetCategoryBit = AssetTools.RegisterAdvancedAssetCategory(FName(TEXT(&quot;GenericGraph&quot;)), LOCTEXT(&quot;GenericGraphAssetCategory&quot;, &quot;GenericGraph&quot;)); // 向注册这种资源类型 RegisterAssetTypeAction(AssetTools, MakeShareable(new FAssetTypeActions_GenericGraph(GenericGraphAssetCategoryBit)));&#125;// 向资源工具绑定创建事件void FGenericGraphEditor::RegisterAssetTypeAction(IAssetTools&amp; AssetTools, TSharedRef&lt;IAssetTypeActions&gt; Action)&#123; AssetTools.RegisterAssetTypeActions(Action); CreatedAssetTypeActions.Add(Action);&#125; 自定义资源在编辑器中的样式 我们可以自定义调整缩略图，颜色，细节自定义，过滤器，分类等。 设置缩略图1234567891011121314151617void FOrfeasPluginModule::StartupModule()&#123;TSharedPtr StyleSet; StyleSet = MakeShareable(new FSlateStyleSet(&quot;OrfeasStyle&quot;)); // 这个插件的内容路径 FString ContentDir = IPluginManager::Get().FindPlugin(&quot;OrfeasPlugin&quot;)-&gt;GetBaseDir(); StyleSet-&gt;SetContentRoot(ContentDir); //从图标创建一个笔刷 FSlateImageBrush* ThumbnailBrush = new FSlateImageBrush(StyleSet-&gt;RootToContentDir(TEXT(&quot;Resources/Icon128&quot;), TEXT(&quot;.png&quot;)), FVector2D(128.f, 128.f)); if (ThumbnailBrush) &#123; StyleSet-&gt;Set(&quot;ClassThumbnail.OrfeasCustomAsset&quot;, ThumbnailBrush); //注册类型 FSlateStyleRegistry::RegisterSlateStyle(*StyleSet); &#125;&#125; 使用IPluginManager.h头文件你需要在你的插件的依赖中添加 “Projects” 依赖 设置过滤器与分类在注册资源类型的时候就设置了 1234// 初始化一种资源类型GenericGraphAssetCategoryBit = AssetTools.RegisterAdvancedAssetCategory(FName(TEXT(&quot;GenericGraph&quot;)), LOCTEXT(&quot;GenericGraphAssetCategory&quot;, &quot;GenericGraph&quot;));// 注册这种资源类型，设置分类与过滤类型RegisterAssetTypeAction(AssetTools, MakeShareable(new FAssetTypeActions_GenericGraph(GenericGraphAssetCategoryBit))); 高级部分：自定义资源编辑器UI 适用于复杂的资源类型 在打开资源的事件中，我们可以给打开事件绑定一个自定义的资源编辑器 绑定了一个自定义的编辑器类型,你需要什么样的编辑器就需要你自己去自定义了，这里主要针对自定义资源插件，就不详细解释自定义编辑器的实现了 自定义编辑器界面]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>插件</tag>
        <tag>自定义资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows编程基础及消息循环详解]]></title>
    <url>%2F2019%2F07%2F24%2FWindows%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%8F%8A%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最近在学DirectX和编写UE4和Windows交互插件时都使用到了Windows的许多API,顺便翻了下Windows核心编程，所以我将相关的Windows编程内容总结与整理下来，本文简要介绍了Windows的一些编程基础，还详细的了解了其中的消息循环。 通俗地说， Win32 API 就是 Windows 系统按照 C 语言语法提供给用户的一个由诸多底层函数和结构组成的集合， 借助该集合， 我们就可实现应用程序与 Windows 操作系统之间的交互。 例如， 要想 通知 Windows 显示某一特定窗口，我们可以调用 Win32API 函数 ShowWindow。 在Windows中，几个应用耜序可以并发运行。因此，硬件资源（如CPU时钟周期、内存、甚至显示器）必须为多个应用程序所共享，为了防止多个应用程序在无序状态下对某些资源访问或修改时所造成的冲突，Windows应用程序不具备直接访问硬件的能力。Windows系统的一个主要任务就是管理当前实例化的程片以及处理多个应用程序之间资源的分配。所以，如果我们想让某一应用程序对其他应用程序产生影响， 只能将该什务交由Windows系统来处理。例如，要想显示一个窗口，必须调用ShowWindow函数。我们无法对显存进行自接的写操作。 事件、消息队列、消息及消息循环介绍通常，Windows程序启动后只是等待某些事件的发生。事件有多种产生途径，一些常见的例子包括键盘中某些键被按下，鼠标单击，或当窗口被创建、尺寸发生变化、发生移动、被关闭、最小化、最大化或变为可见状态时。 当某个事件发生时，Windows会为该驻件所针对的应用程序发送一条消息，表明该事件的发生，井在该应用程序的消息队列中增加一条消息，该消息队列只是一个保存了应用程序所接收到的消息的一个优先队列。应用程序在一个消息循环中不断地循环掉用GetMessage函数（或者是PeekMessage函数）来接受病检查消息队列，这个过程叫做消息循环。当接收到一条消息时，便将其分派给接收该消息的特定窗口的窗口过程。（不要忘记一个应用程序内部可能包含多个窗口）窗口过程是个与应用程序各窗口相关的特殊函数。（每个窗口都有一个窗口过程，但多个窗口可共亨同一个窗口过程。所以，我们就不必为每个窗口都编写一个窗口过程。）窗口过程负责该窗口的所有消息。 消息传递的过程用户或应用程序的某些行为会产生一些事件。操作系统找到事件所属的应用程序，然后向该应用程序发送条相应的消息。然后，该消息就被加入到该引用程序的消息队列中。之后，应用程序不断地检杳消息队列，每当接收到一条消息时，应用程序就将该消息分发给与该消息所属窗口相关的窗口过程。最后，窗口过程执行与当前消息对应的指令。 消息队列Windows操作系统的内核空间中有一个系统消息队列（system message queue），在内核空间中还为每个UI线程分配各自的线程消息队列(Thread message queue)。在发生输入事件之后，Windows操作系统的输入设备驱动程序将输入事件转换为一个“消息”投寄到系统消息队列；操作系统的一个专门线程从系统消息队列取出消息，分发到各个UI线程的输入消息队列中。 Windows的事件驱动模式，并不是操作系统把消息主动分发给应用程序；而是由应用程序的每个UI线程通过“消息循环”代码从UI线程消息队列获取消息。 Windows消息类别 键盘消息 字符消息 鼠标消息 定时器消息 控件消息 跨进程发送数据的消息 消息传递时传递的消息参数 message 各种各样的消息值Windows常用消息大全 消息范围 说 明 0 ～ WM_USER – 1 系统消息 WM_USER ～ 0x7FFF 自定义窗口类整数消息 WM_APP ～ 0xBFFF 应用程序自定义消息 0xC000 ～ 0xFFFF 应用程序字符串消息 &gt; 0xFFFF 为以后系统应用保留 wParam包含虚拟键码（virtual-key code），表示按下或释放的键 lParam包含按键6个字段信息： 重复按键次数（Repeat Count，0～15 位）：通常设为1。大于1说明按键速度大于程序处理能力。可以根据实际需要忽略或处理。 OEM扫描码(scan code，16～23位)：硬件产生的代码。 扩充键标志（extended key，24位）：如果为扩充键（如右侧的Alt键或Ctrl键）按下时为1，否则为0。 保留位（25～28位）：保留位是系统缺省保留的，一般不用。 上下文代码（context code，29位）：如同时按下ALT，标志为1；否则为0。WM_SYSKEYUP或WM_SYSKEYDOWN常为1。WM_KEYUP或WM_KEYDOWN常为0。当所有程序都最小化时，没有窗口具有输入焦点，Windows仍将发送键盘消息给活动窗口；所有的按键都会产生WM_SYSKEYUP与WM_SYSKEYDOWN消息，此情况下如果没按下ALT，该字段为0，这样使最小化的活动窗口不处理这些按键。对于一些非英文键盘，有些字符是shift等组合键产生的，这时内容代码为1，但是其是非系统按键。 键先前状态（previous key state，位30）：键此前是释放的，则为0，还则为1。很明显UP为1，DOWN可以为1或0，为1表示该键自动重复。 转换状态（transition state，31位）：键被按下为0，键被松开时为1。如UP为1，DOWN为零。 在Window程序中捕获消息123456789101112131415161718192021222324252627282930// 在程序窗口被初始化前绑定消息调用函数BOOL InitApplication(HINSTANCE hinstance, int nCmdShow)&#123; HWND hwnd; WNDCLASS wndclass; wndclass.style = CS_HREDRAW | CS_VREDRAW; wndclass.lpfnWndProc = WndProc; //绑定消息调用函数 wndclass.cbClsExtra = 0; wndclass.cbWndExtra = 0; wndclass.hInstance = 0; wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION); wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); wndclass.lpszMenuName = NULL; wndclass.lpszClassName = szAppName;&#125;// 循环调用，并处理获得的消息LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; switch (message) &#123; case WM_CREATE: DragAcceptFiles(hwnd, TRUE); return 0; case WM_DESTROY: PostQuitMessage(0); return 0; &#125; return DefWindowProc(hwnd, message, wParam, lParam);&#125; 在UE4中捕获Windows消息12345678910111213141516171819202122232425static FExampleHandler Handlers;void UWindowsMessageHandlerBPLibrary::WindowsMessageHandlerSampleFunction()&#123; /**获取UE4程序的应用窗口*/ FWindowsApplication* Application = (FWindowsApplication*)FSlateApplication::Get().GetPlatformApplication().Get(); if (Application != nullptr) &#123; Application-&gt;AddMessageHandler(Handlers); // 绑定消息调用函数 &#125;&#125;class FExampleHandler : public IWindowsMessageHandler&#123;public: FString PP; // 使用UE4处理windows消息 virtual bool ProcessMessage(HWND Hwnd, uint32 Message, WPARAM WParam, LPARAM LParam, int32&amp; OutResult) override &#123; if (Message == WM_CAPTURECHANGED) &#123; DragAcceptFiles(Hwnd, true); &#125; return false; &#125;&#125;; 相关了解：句柄是一种指向指针的指针。由于windows是一种以虚拟内存为基础的操作系统，其内存管理器经常会在内存中来回的移动对象，以此来满足各种应用程序对内存的需求。而对象的移动意味着对象内存地址的变化，正是因为如此，如果直接使用指针，在内存地址被改变后，系统将不知道到哪里去再调用这个对象。windows系统为了解决这个问题，系统专门为各种应用程序腾出了一定的内存地址（句柄）专门用来记录这些变化的地址（这些内存地址就是指向指针的指针），这些内存地址本身是一直不变化的。windows内存管理器在移动某些对象之后，他会将这些对象新的内存地址传给句柄，告诉他移动后对象去了哪里。 HWND是窗口句柄，其中包含窗口的属性。例如，窗口的大小、显示位置、父窗口。 HDC是图像的设备描述表，窗口显示上下文句柄，其中可以进行图形显示。 相关文章： Microsoft Windows的消息循环) Windows 常用消息大全]]></content>
      <categories>
        <category>Windows编程</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Windows编程</tag>
        <tag>消息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Window提高工作效率的技巧与工具总结]]></title>
    <url>%2F2019%2F07%2F20%2FWindow%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%9A%84%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[我是一个喜欢折腾的人，特别是在Window上，我一天的大部分的时间都在电脑前工作，学习和娱乐，所以拥有一些好的环境和工具能够极大的提高我们的效率，所谓“工欲善其事,必先利其器”也是这个道理，下面是我3年来在Window提高工作效率的技巧与工具的总结和经验 1.翻越GFW工具为什么这个我排在了第一个介绍？，是因为我觉这东西对于程序员来说是能够极大的提高效率的，就轮百度与谷歌的搜索问题的质量就完全不是一个级别的，跟别说youtube上那么多的免费的优质，第一方的UE4学习资源，而且下面的的很多工具都需要翻墙才能使用或者同步。 刚开始我翻墙是靠着在网上买的账号与接口，但是这样的账号不仅带宽小，而且高峰期特别的卡，刚开始还能忍受，但是后来用了半年竟然被封了，然后毫无音讯。。。然后我就另想办法，决定开始卖国外的vps然后自搭梯子。 然后代理软件我使用Shadowsock进行代理，关于Shadowsocks是一个轻量级[ocks5代理插件，最初用 Python 编写,主要用于翻越GFW(中国国家防火墙),ShadowSocks支持远程DNS解析，可以防止DNS污染。所有数据流量全部经过加密，加密算法可选并支持自定义算法，隐蔽性很强， 相比于传统的VPN方式，ShadowSocks支持PAC列表，根据PAC中的规则进行智能切换，兼顾了访问速度与访问效率。详细的自建与使用可以看我之前的文章Shadowsocks原理和通过VPS自搭代理服务器 而且结合国家前阵子的大面积封禁测试结果来说，国家是完全有能力全面管控出口网络的，所以珍惜当下睁一只眼闭一只眼的情况，能用一天是一天吧。 2.浏览器及其插件的选择与使用浏览器的考虑：关于浏览器我主要考虑了两款：火狐浏览器，谷歌浏览器，火狐浏览器的优点是快速，占用内存少；谷歌浏览器功能全面但是占用内存高，我刚开始的时候是使用火狐浏览器的，但是在使用了一整子后，感觉它的同步功能，和翻译功能，和一些细节上并没有谷歌浏览器做的好，之后我就使用谷歌浏览器了，关于占用内存高的问题，我硬件的方式增加内存解决了，谷歌浏览器一般会占用1g内存，但是我有16g或32g内存的时候，它也就微不足道了。 浏览器插件的选择： Infinity插 — 用于改变并美化你的新建标签页界面 这个插件做的很好，界面不仅简洁美观，还可以自主更改，也能够注册账号保存你所做的所有设置，还有个功能是我没想到的，就是可以在搜索栏点击就可以改变使用的搜索引擎，这对我十分的有用，因为我经常切换搜索引擎进行搜索，这个插件是我所有谷歌插件中使用体验最好的插件。 这是它的大体的样式，壁纸可以点风车进行更换 AdBlock插件 — 广告屏蔽插件 这大概是谷歌插件中使用频率最高的插件吧，它能够屏蔽大多数网站的广告和弹窗 OneTab插件 — 多标签页管理插件 我在搜索的时候经常会打开许多的标签窗口，经常会存留多个博客窗口进行对照查看，这个插件能够对你的标签页进行一键整理和收纳，而且还能减少内存的使用 Tampermonkey — 油猴脚本 这又是谷歌浏览器中的一大神奇，你用谷歌浏览器不用插件，那你只发挥的谷歌浏览器的30%，你用了插件没用油猴脚本，那你也只发挥了50%，这个脚本插件极大的拓展了浏览器的功能，里面的脚本多是一些很有用的破解程序，和一些好用的工具。用户脚本的下载地址为：用户脚本 这些脚本感觉打开了新世界的大门 Imagus — 网页图片自动放大插件 在我们平常的网页浏览中，经常会看到一些图片信息，当时因为网页的缩放和裁剪导致图片模糊不清，放大跳转到另外一个网页查看图片又十分的麻烦，这个插件能让你在你的鼠标悬浮在图片的时候就会自动的展示图片的原图，而不是一张缩略图。 crxMouse — 浏览器鼠标手势插件 谷歌浏览器是不自带鼠标手势的，而鼠标手势又十分的方便，我们可以通过对鼠标手机就实现了对浏览器的前进，后退，刷新，关闭等操作，这些都可以自定义设置，十分的快速 还有一些特定的插件，我会在后面特定的使用情景来进行说明 好用的笔记组合我用过许多的笔记软件，例如印象笔记，为知笔记,gitbook等等，最后都因为使用不太习惯而放弃了，如果你你不强制需要markdown语法的实时预览，那么印象，为知笔记会是一个比较好的选择。gitbook虽然也支持实时预览，但是因为他有一些同步的bug，用了好一整子也只好放弃了。 这时我就整理了我对笔记软件的需求： 要能够使用Markdown语法，且要能进行实时预览编辑，快捷键编辑格式 界面美观，要能够更改样式 要能够随时同步，多端同步 要能够很方便的上传图片，生成图片直链 最终倒腾下来就是这一整套 Typora(本地Markdown)编辑器 + 坚果云(同步云)+七牛云(图床)+MPic(图片上传)虽然看着这一套很麻烦，但是它的确完美的满足的我的需求，十分的好用，值得我去这样折腾，我将会详细的介绍一下这一套软件 Typora这个编辑器对于我来说是完美的，因为以下的优点 Makedown语法的实时编辑，而且Makedown其中的语法都使用了快捷键进行代替，变换各种格式只用一键就可以改变，十分的方面，兼顾了速度和排版 有文档列表视图和大纲视图，打开之后，左边列表就可以看见或选择其他的笔记，还可以看见笔记的大纲，突破了编辑器的限制，使其变成了一个笔记软件，变得好用了 可以自行更改笔记中的格式，样式，只用懂一点html和 css 编辑规则就可以做到，我的样式字体，大小等都做了定制化更改 坚果云坚果云是一个低存量免费的同步盘，刚好用来同步笔记文件，如果只是用来存储笔记和图片这个同步盘根本就不可能用超，而且可以随着电脑启动，每次打开笔记都会保证是最新的编辑内容 七牛云我有时候写的一些博客可能还需要配图，一张图片有了域名才能访问，所以这里就需要一个图床，使用七牛云的前两年都是随便免费的使用，但是从今年开始就需要绑定域名号了，我找我同学要了一个二级域名绑定在图片上 MPic我在平时给图片上床图床的时候觉得非常繁琐，你要得到一个图片的地址，打开七牛云网址，上传图片，返回域名，最后进行粘贴，特别是图片多的时候要操作半天，所以我就在网上找有没有一键上传图片到七牛云的工具，一找还真有，这个软件能够实现截完图，你鼠标的粘贴板就有图片地址，还自动转化为Markdown格式，可以直接粘贴，简化到了极点。 Window平常使用中一些好用的技巧和工具 谷歌浏览器全局一键搜索 我们可以通过按下win键进行浏览器搜索，但是windows默认是使用edge浏览器进行搜索的，但是edge浏览器又很难用怎么办使用一下办法就可以实现按下win键即进行谷歌搜索 首先安装EdgeDeflector软件 然后安装Chrometana谷歌插件 Everything软件 一款非常快的搜索文件工具，我们都知道使用windows搜索文件是非常慢的，这个工具支持快捷键启动，和正则表达式搜索，如果你文件非常多的话，使用这个工具是非常方便的 AutoHotKey脚本工具 这是Windows官方出的脚本工具，用于拓展window的功能，能够自定义实现一些特定的功能，可拓展新极其高，能调用WindowsAPI用非常简单的脚本语言实现一些复杂的功能比如修改window所有的热键，一键打开特定的程序，执行Windows系统级别操作。 我用他实现了一个在实时在光标处显示当前输入法的中英文的脚本，还绑定了一些快捷键和特定的程序 ToDoLisst任务清单工具 小黄条 小黄条只用一个具体的功能，那就是在屏幕右上角记录即将要做的事我每天早上打开电脑开始工作和学习时，都会在todo列表中记录我今天打算做的事情，当我处理完一个任务之后就勾选这个任务，然后这个任务就到了done列表了，这样每天就能够又条理的，不遗忘的处理任务。而且这个窗口能够透明式的悬浮在右上角所有程序的顶层，完美的融入桌面，还能够多端同步。 Trello 这是一个能够详细的记录你整个项目或者任务进展情况的网址，使用网址能够方便的在任何地方查看，其中的任务，项目细节分为正在进行的任务，已完成的任务，未完成的任务，还可以上传附件和图片，其中的项目不仅有个人还能一整个团队共享任务细节，做到任务的发布与实现的查看。 英文文档，博客阅读工具 谷歌浏览器自带翻译 网页右键即可使用，在只用开个大概的外文网站上使用十分方便 有道词典 其中的复制翻译，和划词翻译比较好用，不过我比较看中它其中的一个功能，就是不懂得单词划词翻译后可以收藏此单词，然后收藏的所有单词，都可以自动导入到手机中的有道背单词APP中，我过一整子就会把其中收藏的单词记背一番，这样就能在日常中加强英文文档的阅读能力 淘生词 淘生词是一个谷歌插件，它刚开始使用的时候会把所有的英文词汇标记，当你把光标悬停在标记的词汇上时就会自动浮现这个词汇的中文释义，如果你已经知道了这个词汇的释义，那么你点击这个词汇，那么以后他都不会帮你标红这个词汇了，使用2天之后你的网页上就只会标红你所不会的词汇了，这样你的生词就这样被淘出来了。 特别在UE4的学习过程中，由于国内使用UE4的时间较短，导致许多优质的博客，问答都在国外，而在浏览外文文章时，总会有几个不懂的词汇，这会严重的影响你对这片文章或者回答的理解，使用了这个插件之后他能够减去你面对不会的词的查询的操作，而且你的一个个生词，在看多了之后就都会变成熟词了，使你的词汇量逐渐增加。 总结在电脑的日常使用中，我总是喜欢把一些操作化繁为简，以上的一些工具可能不是那么的必要，但是它能够提高我工作和学习的感受和效率，就像买一个好的键盘，一个顺手的鼠标，一个舒适的人体工程学座椅，他们都是必要的吗？也不是，但是他们带来的感受与变化是潜移默化的是持续你整个的职业生涯的，以上就是我对Window提高工作效率的技巧与工具总结。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>插件</tag>
        <tag>脚本</tag>
        <tag>工具</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4数据解析及字符编码]]></title>
    <url>%2F2019%2F06%2F30%2FUE4%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[最近在实现客户自定义配置数据功能方面，写了许多的数据解析代码，我就将其中的数据解析文件进行了整理，并将数据解析中设计的字符编码深刻的理解了一番 字符编码变换 用TinyXml加载一个xml文档时，由于xml文档是UTF-8编码的，而UE4默认使用的是根据文档的编码方式来加载，在操作过程中需要进行编码转换 了解ASCII码使用1个byte，表示出英文中所有需要的字符（缺点：非英文的字符都无法表示） UNICODE是一个字符集，规定了不同的字符对应于一个唯一的整数，平时所说的使用UNICODE编码其实说的是UFT16编码（顾名思义就是用16位来表示一个字符，有65536个字符），UTF8、UTF16和UFT32则是基于UNICODE字符集的三种编码方式 TCHARTCHAR类型就是通过宏对char和wchar_t的封装，将其中的操作进行了统一。可根据当前平台情况选择对应的类型。_T修饰的字符串常量同理，根据是否定义的UNICODE宏，分别表示””或L”” 转换char 转 TCHAR123TCHAR* outTchar = new TCHAR[iLength + 1];const char *outTchar1 = displayNameNode-&gt;GetText();MultiByteToWideChar(CP_UTF8, 0, outTchar1, strlen(outTchar1) + 1, outTchar, iLength); TCHAR转char123int32 iLength = WideCharToMultiByte(CP_UTF8, 0, *_XmlPath, -1, NULL, 0, NULL, NULL);char* path = new char[iLength + 1];WideCharToMultiByte(CP_UTF8, 0, *_XmlPath, -1, path, iLength, NULL, NULL); 注意：使用wideChartoMultiByte函数时，需要包含stringappiset.h头文件，而使用此头文件有需要包含windows.h头文件 而在UE4中有一个封装好的宏用于char与TCHAR的转换 TCHAR_TO_ANSI - 将引擎字符串（TCHAR*）转换为 ANSI 字符串。 ANSI_TO_TCHAR - 将 ANSI 字符串转换为引擎字符串（TCHAR*）。 注意：这些宏声明的对象的生命周期非常短。它们将被用作函数的参数。无法将一个变量指定到转换后的字符串内容，因为对象将处于作用域之外，字符串将被释放。 传入的参数必须是一个固有字符串，因为参数被类型转换为指针。如传入的是 TCHAR 而非 TCHAR*，编译后运行时将出现崩溃。 用法：SomeApi(TCHAR_TO_ANSI(SomeUnicodeString)); 123UTF8_TO_TCHAR(outTchar)注意：这个宏的声明周期很短所以需要调用完直接赋值 FString转为TCHAR *(TCHAR与FString基本都能自动隐式转换)12Const FString SceneName;const TCHAR *hc = *SceneName; 解析json文件1. json数据格式123456789101112131415161718192021&#123; &#123; “Cultrue&quot;: &quot;ZH&quot; &#125;, &#123; &quot;MusicVolume: 0.3 &#125;, &#123; &quot;SoundVolume&quot;: 0.3 &#125;, &#123; &quot;ReCordData&quot;: [ &#123; &quot;0&quot;: &quot;Defaule&quot; &#125;, &#123; &quot;1&quot;: &quot;Default&quot; &#125; ] &#125;&#125; 解析Json数据示例123456789101112131415161718192021222324252627// 包含Include&quot;Json.h&quot;void SlAiJsonHandle::RecordDataJsonRead(FStingp&amp; Culture,float&amp; MusicVolume,float&amp; SoundVolume,TArray&lt;FSting&gt;&amp;RecordDataList)&#123;RecordDataFileName = FString(&quot;RecordData.json&quot;) //要读取的文件名Relativepath = FString(&quot;Res/ConfigData/&quot;); //文件地址FString JsonValue&quot; //读取的保存数据/**将路径指定的文件读取到一个FString类型的二进制的数组中；*/LoadStringFroFromFile(RecordDataFileName,RelativePath,JsonValue); TArray&lt;TSharePtr&lt;FJsonValue&gt;&gt; JsonParsed; //解析后保存的数组/**读取为JsonReader格式*/TShardRef&lt;TJsonReader&lt;TCHAR&gt;&gt; JsonReader = TJsonReaderFactory&lt;TCHAR&gt;::Create(Jsonvalue);/**解析数据*/if(FJsonSerializer::Deserialize(JsonReader,JsonParsed))&#123;// 根据键值对去获取第一个数据 CulTure = JsonParsed[0]-&gt;AsObject(0)o-&gt;GetStringField(FString(&quot;Culture&quot;)); //获取数组数据 TArray&lt;TSharedPtr&lt;FJsonValue&gt;&gt; RecordDataArray = JsonParsed[3]-&gt;AsObject()-&gt;GetArrayField(FString(&quot;RecordData&quot;)); // 遍历数组数据 for(int i = 0; i &lt; RecordDataArray.Num();++i)&#123; Fstring RecordDataName = RecordDataArray[i]-&gt;AsObject()-&gt;GetStaringField(Fstring::FromInt(i)); //夺取数据 RecordDataList.Add(RecordDataName); // 保存数据 &#125;&#125;else&#123; //解析不成功 UE_LOG(LogSimpleAPP,Warning,TEXT(&quot;Culture = %s&quot;),*Culture);&#125;&#125; 解析XML文件1.使用UE4自带的XmlParser库进行读写XML数据1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Setting&gt; // 每个&lt;&gt;都是一个节点（node &lt;MaxFPS id=&quot;wz9&quot;&gt; //id是属性（attribute) &lt;Setres&gt;1440x720w&lt;/Setres&gt; //一个完整的节点是元素(element) &lt;ScreenPercentage&gt;180&lt;/ScreenPercentage&gt; &lt;/MaxFPS&gt;&lt;/Setting&gt; 解析12345678910111213141516171819202122232425262728//1.模块中包含XmlParser//2.包含头文件#include &quot;Runtime/XmlParser/Public/XmlParser.h&quot;#include &quot;Runtime/XmlParser/Public/XmlFile.h&quot;#include &quot;Runtime/XmlParser/Public/XmlNode.h&quot;#include &quot;Runtime/XmlParser/Public/FastXml.h&quot;bool UReadXMLBPLibrary::ReadXML(FString&amp; MaxFPS, FString&amp; SetRes, FString&amp; ScreenPercentage)&#123; if (FPlatformFileManager::Get().GetPlatformFile().FileExists(*(FPaths::GamePluginsDir()/TEXT(&quot;ReadXML/XmlFiles/Setting.xml&quot;)))) //判断是否有此文件 &#123; FXmlFile* file = new FXmlFile(FPaths::GamePluginsDir() + &quot;ReadXML/XMLFiles/Setting.xml&quot;); // 获取文件地址 FXmlNode* RootNode = file-&gt;GetRootNode(); //获取文件根节点 FXmlNode *MaxFPSNode = RootNode-&gt;FindChildNode(&quot;MaxFPS&quot;); // 寻找数据子节点 MaxFPS = *MaxFPSNode-&gt;GetContent(); // 获取其内容 FXmlNode* SetresNode = RootNode-&gt;FindChildNode(&quot;Setres&quot;); SetRes = *SetresNode-&gt;GetContent(); FXmlNode* ScreenpercentageNode = RootNode-&gt;FindChildNode(&quot;ScreenPercentage&quot;); ScreenPercentage = *ScreenpercentageNode-&gt;GetContent(); return true; &#125; else &#123; return false; &#125;&#125; 2.使用C++常用的tinyxml库进行读写 在工作中详细的使用了tinyxml库进行了xml读写，所以详细的说明 tinyxml使用前的配置步骤 下载tinyxml库 将tinyxml.h、tinystr.h、tinystr.cpp、tinyxml.cpp、tinyxmlerror.cpp、tinyxmlparser.cpp代码拖进同一种 注意：在UE4种使用要讲thinyxml.cpp种#include “thinyxml.h”放在第一个引用，不然会报错 使用了解节点：一种对文档结构的描述对象元素：对文档某一个数据块的描述文本是指没有孩子的节点 节点类可以转换成元素对象。TiXmlElement * pElement = pNode-&gt;ToElement(); 那什么时候需要转换成元素呢？ 当你需要元素的一些属性值是就需要转换了。 元素访问孩子的函数：FirstChildElement() 返回当前元素的孩子元素NextSiblingElement() 返回当前元素的同级元素 节点访问节点孩子的函数：返回当前节点的孩子节点: FirstChild()` 返回当前节点的同级下一个节点: NextSibing() 元素访问和节点访问在一般的访问下没有区别，两者都可以访问的孩子,对于一些特殊的情况下才需要区分。比如你要访问属性时，就需要用元素来找到第一个属性值。 链接节点到上一节点RootNode-&gt;LinkEndChild(SceneNode); 链接文本到节点上MissionNodes-&gt;LinkEndChild(MissionsText); 对于遍历一个xml文档时，思路一般是这样的： 载入一个xml 获得根元素（不是根节点） 循环访问每一个根元素的子元素 对每一个子元素进行解析。获取子元素的类型循环遍历子元素的下一级元素 递归调用第四步 如果定位一个节点 唯一确定一个节点的方法是根据节点名，属性名，属性值 1 根据xml的遍历思想找到与给定节点名一样的节点 2 如果这个节点有属性并且属性名和值与给定的一致，说明找到了。 3 如果没有一致的，说明解析失败。 4 如果没有给定属性名和值，则可以默认只查找与节点名一致的节点。 指针的 new和释放。TinyXml已经帮我们把指针分配的内存进行了管理，在析构函数中进行了处理，我们不需要处理new出来的指针 读取示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &quot;ReadXML.h&quot;#include &quot;Engine/Engine.h&quot;#include &lt;windows.h&gt;#include &lt;stringapiset.h&gt;#include &quot;Paths.h&quot;#include &quot;PlatformFilemanager.h&quot;bool UReadXML::ReadUnitXMLFile(TArray&lt;FString&gt; &amp;str,&#123; // 工程的相对路径+文件名称 FString _XmlPath = FPaths::GameSourceDir() + &quot;Battle.xml&quot;; // 将TCHAR转换char 并转UTF-8编码 int32 iLength = WideCharToMultiByte(CP_UTF8, 0, *_XmlPath, -1, NULL, 0, NULL, NULL); char* path = new char[iLength + 1]; WideCharToMultiByte(CP_UTF8, 0, *_XmlPath, -1, path, iLength, NULL, NULL); TiXmlDocument *myDocument = new TiXmlDocument(); if (myDocument-&gt;LoadFile(path)) &#123; // 获取跟元素 TiXmlElement *RootElement = myDocument-&gt;RootElement(); // 遍历节点 TiXmlElement *lpMapNode = NULL; for (lpMapNode = RootElement-&gt;FirstChildElement(); lpMapNode != NULL; lpMapNode = lpMapNode-&gt;NextSiblingElement()) &#123; GEngine-&gt;AddOnScreenDebugMessage(-1, 10, FColor::Red, &quot;read failed&quot;); const char* outchar = lpMapNode-&gt;Attribute(&quot;id&quot;); TCHAR* outTchar = new TCHAR[iLength + 1]; MultiByteToWideChar(CP_UTF8, 0, outchar, strlen(outchar) + 1, outTchar, iLength); str.Push(outTchar); &#125; &#125; else &#123; return false; &#125; return true;&#125;#pragma once#include &quot;tinystr.h&quot;#include &quot;tinyxml.h&quot;#include &quot;CoreMinimal.h&quot;#include &quot;Kismet/BlueprintFunctionLibrary.h&quot;#include &quot;ReadXML.generated.h&quot;UCLASS()class DCXVEHICLEDEMO_API UReadXML : public UBlueprintFunctionLibrary&#123; GENERATED_BODY()public: UFUNCTION(BlueprintCallable, Category = &quot;YPFUNC&quot;) static bool ReadUnitXMLFile(TArray&lt;FString&gt; &amp;str, TArray&lt;FString&gt; &amp;displayName, TArray&lt;FString&gt; &amp;mission, TArray&lt;UTexture2D*&gt; &amp;icon, TArray&lt;FString&gt; &amp;inconPrefab, TArray&lt;FString&gt; &amp;category, TArray&lt;FString&gt; &amp;load, TArray&lt;FString&gt; &amp;temIndex, TArray&lt;FString&gt; &amp;valid, TArray&lt;FString&gt; &amp;elements); &#125;; 注意 打包后的文件地址，与在开发时的地址是不同的，所以需要根据所处的状态调整读取xml文件的方法 读入示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556bool UReadXML::SaveMapData(const FString SceneName,const FString Mission,const FString Scenes,const FString Missions)&#123; TiXmlDocument *doc = new TiXmlDocument(); // 创建xml文档对象 // 创建描述 TiXmlDeclaration *pDeclaration = new TiXmlDeclaration(&quot;1.0&quot;, &quot;UTF-8&quot;, &quot;&quot;); // 链接到文档 doc-&gt;LinkEndChild(pDeclaration); // 创建根节点 TiXmlElement *RootNode = new TiXmlElement(&quot;Numbers&quot;); doc-&gt;LinkEndChild(RootNode); // 创建子节点 TiXmlElement *SceneNameNode = new TiXmlElement(&quot;SceneName&quot;); RootNode-&gt;LinkEndChild(SceneNameNode); //将节点链接到根节点上 TiXmlText *SceneNameText = new TiXmlText(TCHAR_TO_UTF8(*SceneName)); // 创建Text内容 SceneNameNode-&gt;LinkEndChild(SceneNameText); // 链接内容到Node //Mission TiXmlElement *MissionNode = new TiXmlElement(&quot;Mission&quot;); RootNode-&gt;LinkEndChild(MissionNode); //将节点链接到根节点上 TiXmlText *MissionText = new TiXmlText(TCHAR_TO_UTF8(*Mission)); // 创建Text内容 MissionNode-&gt;LinkEndChild(MissionText); // 链接内容到Node // SceneNote TiXmlElement *SceneNode = new TiXmlElement(&quot;SceneNote&quot;); RootNode-&gt;LinkEndChild(SceneNode); //将节点链接到根节点上 TiXmlText *SceneText = new TiXmlText(TCHAR_TO_UTF8(*Scenes)); // 创建Text内容 SceneNode-&gt;LinkEndChild(SceneText); // 链接内容到Node // SceneNote TiXmlElement *MissionNodes = new TiXmlElement(&quot;MissionNode&quot;); RootNode-&gt;LinkEndChild(MissionNodes); //将节点链接到根节点上 TiXmlText *MissionsText = new TiXmlText(TCHAR_TO_UTF8(*Missions)); // 创建Text内容 MissionNodes-&gt;LinkEndChild(MissionsText); // 链接内容到Node // list TiXmlElement *ListNode = new TiXmlElement(&quot;list&quot;); RootNode-&gt;LinkEndChild(ListNode); // num TiXmlElement *NumNode = new TiXmlElement(&quot;num&quot;); NumNode-&gt;SetAttribute(&quot;i&quot;, &quot;0&quot;); // id TiXmlElement *idNode = new TiXmlElement(&quot;id&quot;); NumNode-&gt;LinkEndChild(idNode); TiXmlText *idText = new TiXmlText(TCHAR_TO_UTF8(*Missions)); // 创建Text内容 idNode-&gt;LinkEndChild(idText); // 链接内容到Node FString XmlPath = FPaths::GameDir()+ &quot;SaveMapData&quot;; int32 iLength = WideCharToMultiByte(CP_UTF8, 0, *XmlPath, -1, NULL, 0, NULL, NULL); char* path = new char[iLength + 1]; //path = _XmlPath; WideCharToMultiByte(CP_UTF8, 0, *XmlPath, -1, path, iLength, NULL, NULL); doc-&gt;SaveFile(path); return true; &#125; XML与JSON的区别XML优点： 格式统一 因为是标准通用标记语言，所以数据共享比较方便 可读性好 缺点： XML文件庞大，文件格式复杂，传输占带宽 服务器端和客户端都需要花费大量代码来解析XML，导致服务器端和客户端代码变得异常复杂且不易维护 客户端不同浏览器之间解析XML的方式不一致，需要重复编写很多代码 服务器端和客户端解析XML花费较多的资源和时间 JSON优点： 数据格式比较简单，易于读写，格式都是压缩的，占用带宽小 易于解析，客户端JavaScript可以简单的通过eval()进行JSON数据的读取 支持多种语言，JSON格式能直接为服务器端代码使用，大大简化了服务器端和客户端的代码开发量，且完成任务不变，并且易于维护 缺点： 通用性不够 使用不够广泛 数据描述性较差 相关博客XML使用：https://blog.csdn.net/lgstudyvc/article/details/77859919 TinyXml节点查找及修改:https://www.cnblogs.com/lyggqm/p/4565749.html]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>数据解析</tag>
        <tag>字符编码，XML，JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DriectX模板缓存技术的理解与应用]]></title>
    <url>%2F2019%2F06%2F03%2FDirectX%E6%A8%A1%E6%9D%BF%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[模板缓存用于获得某种特效的离屏缓存，它允许我们动态的有针对性的将某种像素写入后台缓存中，这使得我们可以实现一些特殊的效果，例如游戏中的镜子，水面反射，战争迷雾等，被应用于游戏中的方方面面。 开启模板缓存 由于模板缓存与深度缓存共享一个离屏的表面缓存，通常是创建的32位缓存，其中24位给深度缓存，8位给模板缓存，有些图形卡可能不支持8位的模板缓存，所以首先要查询设备是否能支持模板缓存，然后将其启用 1Device-&gt;SetRenderState(D3DRS_STENCJLENABLE, true); 开启了模板缓存之后，我们要知道哪些区域是能够被绘制的镜面区域，防止将镜面成像绘制到了非镜面区域（比如墙壁上） 简单来说，模板缓存是用来控制哪些像素会被加载到后台缓存然后被渲染 那么如何对不同的像素（镜面区域）进行判断呢？ 这就使用了模板测试对其进行判断 模板测试的底层原理 其中标记的表达式为 （ref &amp; mask) ComparisonOperation (value &amp; mask) // ref:模板参考值 mask：模板掩码 value: 模板值 我对这个公式的理解为 初始化时先用模板参考值 1 对镜面像素进行标记,然后之后对镜面绘制时，如果这个像素为镜面，那么它的模板值就为 1 ， 然后这个此像素的模板测试就是成功的， 模板掩码是为了在特定情况下减少对比的数字而存在的。 所以我们要对所有的像素进行镜面标记，就比较运算函数设置为模板测试总是会成功1Device-&gt;SetRenderState(D3DRS_STENCILFUNC, D3DCMP_ALWAYS); 将镜面的所有像素都设置为1，对其进行标记1Device-&gt;SetRenderState(D3DRS_STENCILREF, 0x1); // 模板参考值设置为1：所有的模板缓存中的像素都设置为0x1, 模板掩码，用于屏蔽变量的某些位，默认不屏蔽 1Device-&gt;SetRenderState(D3DRS_STENCILMASK, 0xffffffff); 写掩码的值，可以屏蔽写入的模板缓存，默认不屏蔽值 1Device-&gt;SetRenderState(D3DRS_STENCILWRITEMASK, 0xffffffff); 根据像素深度测试与像素模板测试的成功与失败，我们将定义一下3种模板缓存值的更新方式 1.当像素模板测试失败时 1Device-&gt;SetRenderState(D3DRS_STENCILFAIL, D3DSTENCILOP_KEEP); 2.当像素深度测试失败时 1Device-&gt;SetRenderState(D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP); 3.当像素模板测试与像素深度测试都成功时 1Device-&gt;SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_REPLACE); D3DSTENCTILOP的预定义常量有以下 D3DSTENCILOP_KEEP 不史新模板缓存中的值（即，保留当前值） D3DSTENCILOP_ZERO 将模板缓存中的值设为0。 D3DSTENCILOP_REPLACE 用模板参考值替代模板缓存中的对应值 D3DSTENCILOP_INCRSAT 增加模板缓存中的对应数值，如果超过最大值，取最大值 D3DSTENCILOP_DECRSAT 减小模板缓存中的对应数值，如果小千最小值，取最小值 D3DSTENCILOP_INVERT 模板缓存中的对应值按位取反 D3DSTENCILOP_INCR 增加模板缓存中的对应数值，如果超过最大值，则取0 D3DSTENCILOP_DECR 减小模板缓存中的对应数值，如果小千0,则取最大值 应用模板缓存实现镜面效果 因为镜面效果的本质是对像素进行融合预算的结果，所以我们要开启融合运算并对其进行设置 123Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, true); //开启融合运算Device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ZERO); //设置对象融合因子Device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE); //设置目标融合因子 我们设置了模板测试的底层，但是还没有定义在什么情况下模板测试成功 1Device-&gt;SetRenderState(D3DRS_STENCILFUNC, D3DCMP_EQUAL); //设置比较运算函数，为LHS=RHS，就模板测试成功 之后还要设置模板测试成功之后要如何处理缓存 1Device-&gt;SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_KEEP); // 测试成功，就保留模板中缓存中的值 经过以上对模板缓存的处理我们就可以保证镜面反射的信息只会在镜面中绘制了,这时候我们就要开始对反射的物体进行绘制了,根据镜面成像的数学原理： 在DirectX中已经帮我们封装好了对矩阵的转换方法，我们只用设定图像的转换平面就行了 1234567D3DXMATRIX W, T, R;D3DXPLANE plane(0.0f, 0.0f, 1.0f, 0.0f); // xy planeD3DXMatrixReflect(&amp;R, &amp;plane); // 先对其进行对应xy轴进行平移D3DXMatrixTranslation(&amp;T, // 平移完成之后应该对其进行镜像变换 TeapotPosition.x, TeapotPosition.y, TeapotPosition.z); 在对图像进行了镜面转换后，由于图像转换后的深度大于镜面，所以我们要清除转换后的图像的深度缓存 然后对镜面图像进行融合运算 12Device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_DESTCOLOR); // 设置源融合因子Device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO); // 设置目标融合因子 最后还有一个很容易被遗忘的点就是，因为镜面的观察方向与实际物体的观察方向相反，所以我们看到的应该是物体的背面，所以，我们需要对物体的正面的进行背面消隐 1Device-&gt;SetRenderState(D3DRS_CULLMODE, D3DCULL_CW); 最后将其绘制 1Teapot-&gt;DrawSubset(0); 绘制完毕之后，包绘制是更改的绘制设定，改为正常的方式 123Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, false); // 禁用融合Device-&gt;SetRenderState(D3DRS_STENCILENABLE, false); // 禁用对模板的操作Device-&gt;SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW); // 对背面的三角形进行消隐 镜面绘制实例的完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void RenderMirror()&#123; // 对相关的绘制状态进行设置 Device-&gt;SetRenderState(D3DRS_STENCILENABLE, true); //开启镜面缓存 Device-&gt;SetRenderState(D3DRS_STENCILFUNC, D3DCMP_ALWAYS); //设置比较运算函数，模板缓存总会成功 Device-&gt;SetRenderState(D3DRS_STENCILREF, 0x1); // 模板参考值设置为1：所有的模板缓存中的像素都设置为0x1,即对镜面要绘制的部分进行标记 Device-&gt;SetRenderState(D3DRS_STENCILMASK, 0xffffffff); // 设置模板掩码，用于屏蔽变量的某些位，默认不屏蔽 Device-&gt;SetRenderState(D3DRS_STENCILWRITEMASK, 0xffffffff);// 设定写掩码的值，可以屏蔽写入的模板缓存，默认不屏蔽值 Device-&gt;SetRenderState(D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP); // FAIL:像素深度更新失败， KEEP:不更新模板缓存中的值（即保留当前值） Device-&gt;SetRenderState(D3DRS_STENCILFAIL, D3DSTENCILOP_KEEP); // FAIL:像素模板更新失败， KEEP:不更新模板缓存中的值（即保留当前值） Device-&gt;SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_REPLACE); // 设置模板缓存的操作方式，用模板参考值代替模板缓存中的对应值 Device-&gt;SetRenderState(D3DRS_ZWRITEENABLE, false); //设置绘制状态，阻止对深度缓存进行写入操作 Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, true); //开启融合运算 Device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ZERO); //设置融合因子对象 Device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE); //设置目标融合因子 // draw the mirror to the stencil buffer Device-&gt;SetStreamSource(0, VB, 0, sizeof(Vertex)); Device-&gt;SetFVF(Vertex::FVF); Device-&gt;SetMaterial(&amp;MirrorMtrl); Device-&gt;SetTexture(0, MirrorTex); D3DXMATRIX I; D3DXMatrixIdentity(&amp;I); // 创建一个单位矩阵 Device-&gt;SetTransform(D3DTS_WORLD, &amp;I); // 转换为世界坐标 Device-&gt;DrawPrimitive(D3DPT_TRIANGLELIST, 18, 2); //绘制的图元有18个顶点，2个图元 Device-&gt;SetRenderState(D3DRS_ZWRITEENABLE, true); // 设置绘制状态可以对深度缓存进行写入操作 // 只在镜子中绘制反射信息 Device-&gt;SetRenderState(D3DRS_STENCILFUNC, D3DCMP_EQUAL); //设置比较运算函数，为LHS=RHS，就模板测试成功 Device-&gt;SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_KEEP); // 测试成功，就保留模板中缓存中的值 // 对位置进行反射 D3DXMATRIX W, T, R; D3DXPLANE plane(0.0f, 0.0f, 1.0f, 0.0f); // xy plane D3DXMatrixReflect(&amp;R, &amp;plane); // 先对其进行对应xy轴进行平移 D3DXMatrixTranslation(&amp;T, // 平移完成之后应该对其进行镜像变换 TeapotPosition.x, TeapotPosition.y, TeapotPosition.z); W = T * R; Device-&gt;Clear(0, 0, D3DCLEAR_ZBUFFER, 0, 1.0f, 0); // 清除深度缓存，因为茶壶深度大于镜面 Device-&gt;SetRenderState(D3DRS_SRCBLEND, D3DBLEND_DESTCOLOR); // 设置源融合因子 Device-&gt;SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO); // 设置目标融合因子 // 绘制茶壶 Device-&gt;SetTransform(D3DTS_WORLD, &amp;W); // 转换为世界坐标 Device-&gt;SetMaterial(&amp;TeapotMtrl); //设置材质 Device-&gt;SetTexture(0, 0); // 设置纹理 // 反置模式 Device-&gt;SetRenderState(D3DRS_CULLMODE, D3DCULL_CW); // 对正面的三角形进行背面消隐，因为反过来了 Teapot-&gt;DrawSubset(0); // 绘制 // 绘制完成要恢复原来的状态 Device-&gt;SetRenderState(D3DRS_ALPHABLENDENABLE, false); // 禁用融合 Device-&gt;SetRenderState(D3DRS_STENCILENABLE, false); // 禁用对模板的操作 Device-&gt;SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW); // 对背面的三角形进行消隐 &#125; 效果 如果不开启模板缓存就绘制图形，那么在镜面之外的墙面中也会出现茶壶的倒影]]></content>
      <categories>
        <category>图形学</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>DirectX</tag>
        <tag>模板缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏评价日志]]></title>
    <url>%2F2019%2F03%2F03%2F%E6%B8%B8%E6%88%8F%E8%AF%84%E4%BB%B7%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[在看一些游戏编辑，或者游戏评价的时候，有些人总是能一针见血的道出这个游戏的有缺点，写测评也是把一个客观的感觉将其主观化的过程，写这个游戏测评的目的有以下几个： 加强的组织表达能力，和对游戏方面的专业性，加强分享，交流，与文字表达的技巧 在玩完一个好的游戏时，会有一种情感倾诉的需求，而评价日志正是一种自身在游戏体验之后真实情感的自然表达 在写评价时，会反复的查阅资料和修改，会让你更加深入了解这个游戏的背景和衍生文化 在写评价时，你会在思考中将这个游戏的整个过程，将一个个点形成一个面，最后去全方位的思考游戏作者对个游戏的设计思路，从而得到启发与学习、 评价的方法主要从以下几个方面进行： 游戏体验 有意义的时刻 游戏机制 吸引点 戏剧点 区别点 死亡细胞 Roguelite+银河战士恶魔城(全新类型：RogueVania)：类似银河战士恶魔城类游戏，玩家将在相连世界中体会逐渐探索的乐趣，且游戏将兼有Roguelike游戏的重复可玩性和刺激的永久死亡体验。 这款游戏具有较高的综合素质，特别是游戏的色彩绚丽鲜明的美术风格最为出色，具有Rouguelike游戏特点：技能，武器，道具较为丰富，且不同的搭配会出现不同的效果，每次随机生成的迷宫，且不会重复，怪物种类多样，关于永久死亡会掉落一定金币这一特点，在增加玩家的刺激感的同时隐性的增加的下次挑战成功的机率，有效的激励了玩家，且会有一些剧情会通过NPC,关卡末，隐藏的形式传递给了玩家，会使得玩家对接下来的剧情好奇。 总结：这是一部素质过硬的刷刷刷游戏，简单的游戏形式下隐藏着许多优秀的细节。末世孤雄 这是一个ADV类型的文字冒险游戏，定义为拔作，改编自小说《在遍地都是丧尸的世界里唯独我不被袭击》，主要剧情是默默无闻的，混混过日的男主角在崩坏的僵尸世界，只有他不被僵尸袭击从而引发关于欲望的故事 ​ 这部作品定义为拔作，从世界观到剧情这部作品都牢牢的抓住了玩家的欲望，剧情紧凑不拖拉，悬疑氛围到位，人物在末世所做出的选择都是实际会做出的选择，贴近现实，带入感很强。所塑造的角色都鲜明丰满，特别是女主角的塑造与设定十分的出色，女主藤野深月柔弱，率真，坚强的性格激发了玩家的保护欲，而且立绘也十分的诱惑，作画质量高。 ​ 关于剧情方面，女主角女主角是个家境学习都十分优越的清纯少女，被男主胁迫，后来在慢慢在相处中发现了男主角色的闪光点喜欢上了男主，这样的剧情作为拔作虽然十分的狗血但是是十分吸引人的，大多数拔作对这样的过程的剧情的合理性都不是很重视，导致十分的无脑。但是在末世孤雄中却惊讶的发现对这过程的处理却十分的合理与流畅，这是十分难得的。剧情虽短，但后续的剧情内容不仅有铺垫伏笔而且不断的冲突点引发出来，具有一定的深度。 总结：这是一部综合素质很高的作品，其中紧凑的剧情节奏，优秀的人物塑造是其中的亮点。Gris 《Gris》是一款2D横版动作冒险游戏，这是一款用画面和音乐来表达一段对自己内心世界探索的独立游戏，游戏通过进程的不断推进，从而了解到其内心的痛苦 ​ 这款游戏最优秀的就是其的极简的画面，大片或柔和或绚丽的水彩效果表现的艺术感十足，而其中颓垣的岩壁，残存的树叶，随着画面变换而撒下的绚丽的阳光，怪异的生物，多层次的背景这一切都交融了现实与梦幻。而其中音乐与画面，节奏的结合也是十分到位，在机关上跳来跳去时的低沉平缓，探索世界时的悠长宁静，与怪物斗争时的紧促激烈，不同场景的不同风格，其中的音乐衔接十分自然，画面，节奏，音乐的结合让人沉浸其中。 ​ 而这款作品也有着不少的缺点，虽然游戏的定位十分的明确，定义为休闲玩家，游戏的难度强调零挫败，但是由于关卡设计的不够巧妙，亮点不多，不能给人眼前一亮的感觉，在被画面吸引的玩家在视觉疲劳之后没有精巧的关卡就很容易厌倦。而其中主要吸引玩家的剧情，感情线虽然在游戏中随处的雕像，生物，细节都暗示着其中的感情主旨，但是其中的感情的表达十分的平淡，缺乏故事性，缺乏故事随着进程的变化而变化，由于感情的画面与音乐渲染的感情十分突出，但是感情的表达却十分的平淡，所以显得缺点十分突出。 总结：这部作品的画风，音乐，对感情的渲染十分到位，但在玩法，故事上有一些瑕疵。]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>游戏设计</tag>
        <tag>评价</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4插件开发]]></title>
    <url>%2F2018%2F12%2F27%2FUE4%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[很多虚幻引擎中的子系统都被设计为具有可扩展的能力，能够在不直接修改引擎代码的前提下，插件为引擎添加完整独立的新功能， 或者修改引擎中内建的功能。可以为引擎创建新的文件类型，为编辑器添加新的菜单项或者工具栏按钮， 甚至增加一个完整的全新功能模块或者编辑器的子模块 文件目录 插件类型 搜索路径 引擎插件 /UE4 root/Engine/Plugins/My Engine Plugin/ 游戏插件 /My project/Plugins/My Game Plugin/ 虚幻引擎通过查找 .uplugin 文件来定位插件。我们把这些文件称为插件描述器，这些文件是文本文件，提供了插件的基础信息。 虚幻引擎、编辑器以及编译工具（UBT）在运行时，会自动发现并加载插件描述器。 如果插件具有 Source 目录的模块（以及 *.Build.cs 文件），插件的代码会自动添加到生成的 C++ 项目中，这样便能更容易的一边开发游戏一边开发插件。 每当编译游戏项目是，任何带有源码的插件也会根据游戏的依赖关系一并被编译。 引擎插件有一个特殊的要求：引擎的代码模块必须不能够有任何静态链接依赖到引擎插件的模块库上。 也就是说，引擎的插件必须要保持不被引擎依赖的独立性——插件模块必须不能够成为“被引擎依赖的模块”。这是一个设计哲学上的选择， 这样能够让引擎在这些插件不可用的时候仍然能够工作正常。 插件描述器配置‘1234567891011121314151617181920212223&#123; &quot;FileVersion&quot;: 3, &quot;Version&quot;: 1, &quot;VersionName&quot;: &quot;1.0&quot;, &quot;FriendlyName&quot;: &quot;ReadXML&quot;, &quot;Description&quot;: &quot;ToReaderXML&quot;, &quot;Category&quot;: &quot;Other&quot;, &quot;CreatedBy&quot;: &quot;RocYing&quot;, &quot;CreatedByURL&quot;: &quot;&quot;, &quot;DocsURL&quot;: &quot;&quot;, &quot;MarketplaceURL&quot;: &quot;&quot;, &quot;SupportURL&quot;: &quot;&quot;, &quot;CanContainContent&quot;: true, &quot;IsBetaVersion&quot;: false, &quot;Installed&quot;: false, &quot;Modules&quot;: [ &#123; &quot;Name&quot;: &quot;ReadXML&quot;, &quot;Type&quot;: &quot;Runtime&quot;, &quot;LoadingPhase&quot;: &quot;PreLoadingScreen&quot; //插件在什么时候会被加载 &#125; ]&#125; Type这里的类型设置决定了该插件适合于那种类型的应用程序加载,有以下几项：Runtime 的模块在无论何时都会被加载，哪怕是在最终发行的游戏版本中也会。 Developer 的模块只会在 Development 运行时或者编辑器版本中才会被加载，并不在在最终发行版本中加载。Editor 模块只会随着 Editor 的启动被加载。 插件也可以使用几种不同类型的组合来达到所需要的目的。 示例：XML解析插件123456789101112131415161718192021bool UReadXMLBPLibrary::ReadXML(FString&amp; MaxFPS, FString&amp; SetRes, FString&amp; ScreenPercentage)&#123; if (FPlatformFileManager::Get().GetPlatformFile().FileExists(*(FPaths::GamePluginsDir()/TEXT(&quot;ReadXML/XmlFiles/Setting.xml&quot;)))) //判断是否有此文件 &#123; FXmlFile* file = new FXmlFile(FPaths::GamePluginsDir() + &quot;ReadXML/XMLFiles/Setting.xml&quot;); // 获取文件地址 FXmlNode* RootNode = file-&gt;GetRootNode(); //获取文件根节点 FXmlNode *MaxFPSNode = RootNode-&gt;FindChildNode(&quot;MaxFPS&quot;); // 寻找数据子节点 MaxFPS = *MaxFPSNode-&gt;GetContent(); // 获取其内容 // 获取Setres字段内容 FXmlNode* SetresNode = RootNode-&gt;FindChildNode(&quot;Setres&quot;); SetRes = *SetresNode-&gt;GetContent(); FXmlNode* ScreenpercentageNode = RootNode-&gt;FindChildNode(&quot;ScreenPercentage&quot;); ScreenPercentage = *ScreenpercentageNode-&gt;GetContent(); return true; &#125; else &#123; return false; &#125;&#125; 然后就能在所有蓝图中调用了 注意：1.在插件中使用了什么模块在在.Build.cs包含此模块 1234567PublicDependencyModuleNams.AddRange(new string[]&#123; &quot;Core&quot;, &quot;XmlParser&quot;&#125;) 2.插件系统是独立于本体的系统 3.在游戏中创建了SCompondWidget类将其移动插件中时需要将API模块说明符删除 “模块名”_API]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>插件</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏分析日志]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[游戏分析是一个专业性很复杂的工作，其中的各个系统的框架都十分的复杂，其中的玩法，用户，数值等都是值得深入的去理解。进行一个游戏分析，可以让我们能够让我们从更深的层面去理解游戏，只有透彻的理解了一个游戏，才能更好地去思考设计者的想法。 进行游戏分析的一个方法，就是带着各种问题去理解游戏比如： 这个功能的作用是什么？ 作者为什么要这么设计？想要达到什么目的？ 这个功能会达到什么样的预期效果？ 这个功能为什么好？ 自走棋游戏分析 最近在准备面试，却因为在开学前玩了下Dota2 自走棋，却意外被其深深吸引，在学习的之余的休息时间都在下棋，这个游戏我觉得很有分析意义与参考意义。 因为我觉的Dota自走棋相对于类似的游戏炉石传说，昆特牌等卡牌类游戏的优点很明显，这个游戏特别像麻将，随机的发牌，随机的抽牌，然后靠着宏观的控制去赢得比赛，像麻将一般根据自己所抽到的牌乃根据情况来胡牌，如果强行的凑某一种牌反而会降低胜率。 关于这个游戏最出色的就是核心玩法，我觉得这类棋牌类游戏的玩法核心有以下几点：随机性，策略性，养成运营 随机性关于随机性是游戏的一大特性，大到彩票，抽奖，小到摇塞子，赌博，划拳等无一不体现出随机性所带来的巨大魅力，随机性之所以这么收到追捧，有以下几个原因： 随机性会使人期待，期待会使人专注，在意 随机性会使人惊喜，气馁，而一个游戏能够牵动玩家情绪的变化，那么这个游戏也就成功了一大半 随机性会带来变化，让游戏每一局都不一样，人们是喜欢变化的动物，一成不变的事物是枯燥 策略性光有随机性还是不够的，一个好的游戏还得有足够的策略性去把控随机的事件，自走棋的策略性体现在一下几点： 棋子间的各属性，技能的搭配，成为胜利的关键 限定的等待区棋位，让玩家不得不去做一些选择与取舍。 所有人都公用一套棋库，让玩家去可以卡某一玩家的牌或者一类型的牌成为了现实，所谓胜利可以是自己够强大，也可以是别人够弱小 可以查看别的玩家的情况，并根据情况调整策略 可以自由的安排棋子的站位，不同的站位效果不同，会产生不同的结果 这一切策略性的选择，最后会形成对大局观的把控，而这些大局观的把控正是技术差距的体现。 养成这个玩法点本来是属于网游或者想模拟人生等养成游戏的核心玩法，自走棋将其合理的融入其中，使得他成功的区别于常规的卡牌类游戏，成为了游戏的一个亮点。 ​ 养成的要素主要体现在你所选择的棋子每三个一星棋子会升级为二星棋子，每三个二星棋子会升级为一个三星棋子，这样的升级跟神奇宝贝的进化，与变身是同样的效果，你所做的努力产生了正面的反馈，会让玩家产生自豪与满足，而更高级的棋子也更加的酷炫，更加激励忘记，而随着你连胜而变得越来也越大的信使也是处于这样的原理。 一些细节透露出的优点 对优势方的奖励，对劣势方的补贴平衡优劣势方的游戏体验，一直都是对抗类游戏的设计重点之一 自走棋对优势方的奖励有： 5，7，10连胜的所有玩家公屏显示，这是一种优势的炫耀，能够让玩家感到心情愉快 随着连胜，你的信使会变得越来越大，飞的越来越高 连胜会慢慢所获得的金币数，这些经济会成为获胜的关键 自走棋对劣势方的补贴有： 劣势方会有劣势金币的补贴，补贴数量与连胜方一致，不过会有掉血的代价 如果有人一直不掉装备，那么会给一个魔法芒果回1-5的金币，或者是回1-10的血量 这样做的目的可以让有优势的人一直获得优势的快感，而然劣势的人不至于崩盘，也有隐忍一波后，强势翻盘的机会，这样的机制跟英雄联盟的赏金机制是类似的 让策略类游戏能够与好友开黑如果一个游戏能够加入开黑，社交的属性，那么这个游戏的推广也会占有极大的优势，而卡牌类的游戏如何巧妙结合能够让一局游戏能够与朋友一起分享，这一直是一个难题，炉石传说也做过一些联机对抗的尝试，但却都有点显得鸡肋，而9个玩家相互厮杀的吃鸡形式，又正是自走棋的一大创新，他让与队友配合成为可能，如果有幸与队友最终battle,也会十分的激情与快乐。]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>游戏设计</tag>
        <tag>游戏分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4碰撞解析]]></title>
    <url>%2F2018%2F11%2F16%2FUE4%E7%A2%B0%E6%92%9E%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在游戏中常见的带有物理的物体一般有5种，胶囊体一类、静态网格物体StaticMesh、骨骼网格物体SkeletalMesh、Landscape地形以及PhysicsVolume（BrushComponent），UE4继承了PhysX物理引擎，来模拟刚体的物理行为，包括碰撞响应，由于碰撞检测所出现的BUG不在少数，我也是在解决类似绝地求生经常有的碰撞之后飞天的BUG中加深对物体碰撞的理解的。 一.任意两个物体碰撞的条件有：1.两个物体都拥有Collision组件 2.其中有一个物体开启了simulate Physics Collision组件 Collision实际是对碰撞进行监测追踪的组件 属性：Simulation Generates Hit Events（模拟生成碰撞事件）：是否会调用Event Hit(碰撞事件)和On Component Hit(组件碰撞)事件 Generate Overlap Events(生成重叠事件)：会调用重叠事件，比如Event Actor Begin Overlap(Actor开始重叠事件)或Event Actor End Overlap(Actor结束处重叠事件) Can Character Setp up on :玩家撞到物体后是否能够走上去 Collision Presets :碰撞的预设类型 123No Collision（无碰撞） - 不同该对象发生碰撞，无论是踪迹碰撞还是物理碰撞。No Physics Collision（无物理碰撞） - 该刚体仅用于射线投射、扫射及重叠。（4.9之后改为Query Only)Collision Enabled（启用碰撞） - 该刚体用于物理模拟和碰撞查询。 碰撞类型通道有（CollisionChannel)： 12345678910Camera:摄像机能否穿过次物体world Static : 静态物体World Dynamic : 动态物体Pawn ： 控制器PhysicsBody : 刚体Vehicle : 交通工具（只会和WorldStatic、WorldDynamic发生碰撞）Destructible : 可破坏纹理物体Projectile : 子弹，抛射物Spectator只和WorldStatic发生碰撞（因为是观战者，不能干扰比赛，但也不能陷到地底下去啊） Trigger只和WorldDynamic发生“碰撞” USe CCD：是否针对该对象应用 Continuous Collision Detection（连续碰撞检测） 。增加碰撞检测的准确度。 Always Create Physics State（总是创建物理状态）： 通过需要时才去创建物理状态（碰撞属性）来减少计算对象的物理状态来提高性能。 Multi Body Overlap（多个刚体重叠）：为同一物体的多个刚体生成不同的重叠事件。 Check Async Scene on Move（移动时检查异步场景）：如果该项设置为 真 ，那么组件将在两个物理场景（同步和异步）中都查找碰撞。异步场景主要由可破坏网格物体的破碎块使用。 Trace Complex on Move（移动时跟踪复杂碰撞）：如果该项设置为 真, 扫过该组件的对象将在运动时跟踪复杂碰撞。复杂碰撞简而言之就是基于每个面的碰撞，而简单碰撞则是您的球体、胶囊体、盒体及生成的凸面体形状。 Return Material on Move（移动时返回材质）：设置该项为 真 将返回物理材质到 Hit Info（碰撞信息） 中 Physics组件 碰撞的发生需要靠Physics simulating(物理模拟)，如果其中一方没有设置物理模拟，那么就算怎么设置Collision也不会发生碰撞的，Collision起到的作用是去监测碰撞的发生。 属性Simulate Physics模拟物理效果：开启物理模拟，碰撞的必要条件之一 Mass in KG质量 KG为单位：物体的重量 Angular Damping角度阻尼：阻塞旋转的力的大小 Linear Damping线性运动阻尼：阻塞移动的力的大小 Enable Gravity是否启用重力：启用重力 Lock Position（锁定位置）: 锁定某个方向不发生位移 Lock Rotation（锁定旋转）：锁定不向某个方向旋转 Mode（模式）：不同的限制移动方向 Auto Weld（自动连接为整体）: 将会与父控件组成一个整体进行物理模拟 Start Awake开始时唤醒：实体是在游戏开始时就唤醒物体模拟，或是一开始处于待唤醒状态 Center Of Mass Offset重心偏移：从计算后的位置再增加一个特定的重心偏移 Mass Scale重力的缩放比例：每个实例的重力缩放比例 Max Angular Velocity最大角速度：实例的最大角速度 Use Async Scene使用异步的场景：如果勾选的话，实体将会放在异步的物理场景中。如果不勾选，他就会放到同步的物理场景。如果实体是一个静态实体，无论bUseAsyncScene是什么值，他都会直接被放在两个场景 Override Max Depenetration Velocity覆盖最大的重叠移动速度：这个实体实例是否有自己的最大重叠移开速度（脱离碰撞的速度） Max Depenetration Velocity最大脱离重叠速度: 最大脱离重叠速度 Walkable Slope Override重写在该实体上可行走的坡度：自定义的可行走坡度 Walkable Slope Behavior可行走的坡度行为：表面的行为（就是 是否影响行可走的坡度） Walkable Slope Angle可行走的角度：覆盖可以行走的斜度 Sleep Family休眠集：一个决定集合，决定什么时候让实体静止不动（Normal适合大部分情况，不过在某些弧形移动的转折点或者钟摆的速度非常小的地方会导致物体静止。sensitive即使在这两个情况下也不会停止运动。） Position Solver Iteration Count位置计算迭代数：物理实体计算位置的迭代次数。次数越多，对CPU的消耗越大，但是移动动作会越平稳 Velocity Solver Iteration Count角度计算迭代数：物理实体计算角度的迭代次数。次数越多，对CPU的消耗越大，但是旋转动作会越平稳 Should Update Physics Volume是否更新物理体积：当组件移动时，重叠的缓存物理体积是否被立即更新 小技巧：1.使用编辑视图的Player Collision可以看到玩家的碰撞世界 2.在项目设置中可以添加对象通道和踪迹响应通道 注意：1.父控件的simulatePhysics开启，那么子组件的Simulating Generates Hit Events开启，必定会响应子组件的OnCompnentHit事件 2.Actor的子组件的OnComponentHit事件响应，那么父Actor的OnActorHit也会响应 3.有些Static Mash开启了simulat physics 但是没有效果，原因是没有在网格编辑界面添加碰撞盒，和在Collision Complexty选项选取 Use Complex As Simple,如果设置了复杂的碰撞盒也同理，设置反了容易无法正确模拟出物理碰撞。 4.Collision使用的碰撞体是继承自Mesh的，在MeshEditor编辑 123有三种选择，第一种是Simple，第二种是Complex，第三种是Default。Simple：Mesh的碰撞体全部由简单立体图形组成，比如Sphere，Cube等等，可以手工添加和删除，与Mesh本体的匹配度不是很高，但是只有Simple支持PhysicsSimulate，这个是重点。 Complex：每一个Ploy都会计算碰撞，计算量相当大，于是不支持PhysicsSimulate，实用Complex碰撞之后，如果再使用物理模拟的话，会穿过底面掉到无穷远去。 5、人物运动就是我们人物的运动受控于两个大组件，一个是物理引擎，还有一个是MovementComponent。MovementComponent一定要注意，它很容易被忽视，比如CharacterMovementComponent，它的内部也实现了一个重力移动逻辑，和物理引擎是完全独立的！当你杀死一个人之后，把他的CapsuleComponent设置为Overlap，你就会发现他的CapsuleComponent陷到地下去了，你关了SimulatePhysics，关了GravityEnable都不行，这就是因为他的CharacterMovementComponent内部还是有一个重力逻辑，会使他落下，加上你把他的碰撞关掉了，所以他就陷到地底去了。 6.当使用AddActorWorldOffset对人物进行移动时，人物将不会发生碰撞，因为是强制位移，要使用就要勾选Sweep。 7.有时不可避免的也会出现穿墙现象，是因为检测是按照帧来的，所以当你速度够快或者正好卡在某个帧检测之间碰撞了，是会出现穿墙现象，可以另外写逻辑来判断解决，例如：绝地求生穿到地底或者墙里面的情况。 特殊使用场景1.当我们要创建一个透明的墙，或者做某个复杂Actor的碰撞体积时使用基础组价的BlockingVolume即可 2.当我们要为一些使用画刷工具创建出来的StaticMash物体时，想要为其添加体积碰撞在StaticMash物体的StaticMash组件下拉隐藏界面中有一个（CreateBlockingVolume)选项，点击此选项将会将会根据此物体的不同形态常见不同的透明碰撞盒 参考博客physics:https://blog.csdn.net/u012999985/article/details/51078906 UE4中的Collision（碰撞）规则梳理 https://blog.csdn.net/SittingAtThisMoment/article/details/80118748 碰撞参考指南 http://api.unrealengine.com/CHN/Engine/Physics/Collision/index.html UE4蓝图碰撞检测解析 https://blog.csdn.net/u012999985/article/details/51113853 UE4碰撞规则详解(2016.7.12更新) https://blog.csdn.net/zhangxsv123/a]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>碰撞</tag>
        <tag>Collision</tag>
        <tag>Physics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大二暑假参赛or实习记录]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%A4%A7%E4%BA%8C%E6%9A%91%E5%81%87%E5%8F%82%E8%B5%9Bor%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[参赛缘由: 刚开始想要去参加比赛的缘由是因为在4月份的时刚刚通过公司面试，成为一名的UE4游戏开发实习生，心中感到高兴的同时却转念一想我好不容易和游戏开发一起学的iOS开发，积累到终于能随便实现各种功能的时候，却什么成果还没得到的时候却要换个开发方向了，心中难免有些有些不甘心（因为我认为做技术始终需要一个一个小的成果，来激励你不断地去学习，自己始终要觉得自己做的东西是很厉害，很酷炫的东西，而不是密密麻麻的一行行代码，这种反馈的成就感对我很重要）而且自己对比赛的答辩和路演比较感兴趣，想借此提高自己的表达沟通能力，也想借此看看其他高校的作品，互相交流学习。 用精巧的逻辑砖块构筑庞大的虚拟世界 ——程序开发 参赛过程中国大学生计算机大赛省赛开始 既然决定要参赛了，就去看了当时适合的比赛有“ 中国软件杯中国大学生软件设计大赛”，“中国大学生计算机大赛“，”中国高校计算机大赛-移动应用创新赛“；刚好当时有个机电院的同学家威找到我们说他有个idea想要我们去实现成应用，他当时不仅把他想法的PPT做好了，而且连APP的界面都手绘画好了（以前也有人想找我们做东西，但是大部分人都止步于想法阶段，而没有去认真的分析，实施）我们介于他对这件事的用心，听了他的运动+社交的概念也觉得可以做，于是家威做app的产品经理，我负责ios端功能的开发， 和实验室做android开发的中诚同学负责android端功能的开发就准备去参加计算机设计大赛了，当时距离计算机大赛省赛截止时间只剩最后一星期了，我们赶紧加班加点写出个原型， 然后让家威去按照题目要求去准备材料和PPT,在准备的时候看了看我们学校别人的参赛项目都准备的那么全面，一个物联网项目连移动端的app都做了，仓促的提交之后本来都不太报有希望能够晋级，过了几天却峰回路转通知我们晋级了，在高兴之余我们不断的优化作品，之后参加省赛也顺利晋级了国赛。 软件杯or移动应用创新赛的想法 计算机大赛距离国赛有很长的一段时间，为了 准备国赛，我们去视觉传达学院找来了一个做UI设计的静姐帮我们重新设计UI界面，刚好暂时没我什么事，我就想自己去准备一个项目，于是去看了看软件杯的赛题，有个AR的赛题——采用AR技术的旅游APP,目的是解决使用AR技术去解决旅游地的痛点，我一看想了想，然后去查了查实现AR所需要的技术，发现所需要的ios开发，Unity3D，Unreal4引擎我不都刚好会嘛！，于是想用Unreal4去实现他，刚好用比赛促进我UE4的使用，岂不两全齐美？既然要参加的赛题决定了，就要开始想切入点了 这是当时中国软件杯中国大学生软件设计大赛的赛题 我当时想了几天，总结总结了几个自己决定还行的想法，拿着这几个想法我去和指导老师洪蕾老师交流了下，（老师对于这方面很有经验）老师说尽量把旅游的痛点做的精细化，经过一番交流，我觉得应该和现有的公共设施相结合，拍脑袋一想突然想到了我们可以将AR技术运用在路牌上，当想出这个点子的时候我觉的很不错，然后就决定做这个方向了，然后我们觉得这个想法创新点也很好，修改下功能与需求也就连着苹果公司与浙江大学的”中国高校计算机大赛-移动应用创新赛“也一起申报了。 开发的过程 当我正式开始做的时候才发现有各种各样的突发困难，之前打算用UE4做AR的结果这个项目，因为用到了iphone的各种定位，与识别技术，所以只能使用iOS原生框架AR Kit去开发它，而且这一技术框架是半年前苹果公司才发布的，网上的学习资料特别的少，原理的学习基本只能看官方文档，功能的学习基本只能去github看别人的源码，当时github上star数比较多的ARKit库基本都看了个遍（当时明显觉得自己读源码的速度快了非常多），而且既然要参加一起参加移动应用创新赛就要使用swift语言开发，我之前一直都使用OC语言开发的，没有办法只能硬着头皮上，开心的是做AR开发还是很有趣的，我还在闲暇时实现了一些其他有趣的功能。 当时第一次把基本功能验证成功截得图，当时被BUG困扰了很久，终于成功十分激动！ 在我把功能的可行性验证成功之后，决定去组建一个团队，找到了实验室做前端开发的浩楠来做后台的数据传输，和做交互设计的同学对软件进行交互设计和文档的编写，我们一起讨论了许多需求，和功能解决方案，编写了需求规格说明书，详细设计说明书，算法描述和软件说明书，测试文档，制作介绍PPT，介绍视屏等，为了测试旅游地路口多路牌识别的实际效果，还专门去了学校附近的方山景区测试实验，现场调试BUG，当成品完成已经1个月后了，刚好到了我为这个项目设定的事件，因为8月份之后就要准备考试，考完试就马上要去公司实习了，我已经做了很完整的准备，对这个项目很有信心，之后这个项目的两个比赛也顺利的通过初赛，复赛进入国赛。 决赛前的准备 在比赛前并没想那么多，做的时候也只是想着如何完善这个作品，之后晋级了他突然发通知来能够去公费清华大学参加沙龙讲座，去浙江大学参加暑假集训营培训，因为高校计算机大赛的暑假集训营和中国大学生计算机大赛决赛事件重了，就让我们组的两个队员去了，然后我去参加计算机大赛的决赛，不过清华大学的沙龙讲座我是去了的，当我们做了5个小时的高铁，进入清华校园时立即就感受到了满满的人文气息，跟如今各种在郊区扩建的空旷大学城完全不同，虽然只在清华经管院开了1天的沙龙讲座，但是其中的质量很高啊，专业创新团队告诉了我们创新的出发点，如何有目规范的去培养创新思维，创投公司创投人让我们认识到了创业的残忍，苹果公司中国区负责人让我们了解到一个优秀的产品应该具有什么样的特质，如何去完善自己的作品。在参加完沙龙讲座，那肯定是在畅游首都北京啊！在短短了两天里我们去了充满艺术美感的天坛，威严壮观的天安门，源远流长的故宫，万园之园的圆明园等，在觉得赞叹的同时不仅感叹幸好之前一激动就参加了这些比赛，感觉乘年轻学生票还半价的时候就应该多尝试，多看看，多学学。 参加培训时的合影 实习的过程 因为是第一次找实习，还不知道自己的技术处于什么水平，而且自己也才大二，投简历的时候就投了一个离学校较近的小公司，（还想着没有那么容易通过）结果第一份简历就通知我去面试了，面试也很顺利的通过了，之后就签订了实习协议，进入公司之后发现这个公司是大公司的子公司，我们这个项目组是用画面较高的UE4引擎为军方做3D化作战平台模拟的，给我印象深刻的是老板的个人能力非常强，果然得出来才能看到更多厉害的人啊，才能认识到自己的弱小。 因为刚进入公司的时候觉得自己水平菜，也才大二，其他同时进入的实习生都是985大学的应届生，整个暑假实习阶段都十分认真的上班，6点下班回来基本也都整理一天所做的东西或者思考在上班时没解决的BUG到10点半才从实验室回宿舍，由于UE4是个2015年才新开源的游戏引擎，学习资料少，学习成本高，开发人员少，所以项目负责人伟哥叫我写的各种功能模块基本没有借鉴的，基本就啃着源码，根据自己的底层的理解器去实现他，出现问题和BUG也基本在国内浏览器找不到解决方法，只能去国外论坛找相似的经验，实在不行也只好请问伟哥，伟哥虽然挑起整个项目的重担，能力很强但是有些问题也属于不可预期性的而且UE4引擎系统也比Unity3D复杂很多，也没有解决的方法，只能自己换种实现方式，或者回去之后慢慢排错。 在这种每天不停思考的日子，了解被UE4魔改的C++的各种用法，C++与蓝图之间的互相联系，转换等等。我自己感觉进步飞快，从刚开始实习时，蓝图C++之间使用不是很熟练的状态变成了想写什么功能，解决BUG都总有办法的状态，之前虽然学习了UE4和Unity的各个模块功能的使用与编写，但是叫我去随便写一个功能是做不到的，感觉这次实习就像把学校关门造车的浅水区突然丢到了你去给我实现某个功能的深水区，加深了 自己对UE4整个游戏引擎的理解性与联系性，增强了自己的开发信心。 公司由于是个军方出资的企业，也没有游戏公司上线的压力，做的是整体的规划，整个公司氛围也是很好了，基本每个星期都有活动，或是打羽毛球，或是游泳，或是吃饭，老板还鼓励我们去看科幻电影，玩军事游戏来提高自己去实现功能的想像力，还在我们办公室专门安装了几台显示器来在下午累的时候看看科幻电影，公司还养了只猫，大家累时候都喜欢撸猫，暑假实习的2个月很快就过去了，不过我签的是1年的合同，上学没课的时间也会去公司上班。 在我暑期实习阶段出生的一群可爱的小猫 最终的决赛 中国大学生计算机大赛的决赛是是先在上海东华大学进行，我们就感受到了满满的教育部直属比赛的风格，处于郊区的校区，不统一安排住宿，很远才能有酒店，吃的只有食堂的快餐，底下一堆资历深的老教授评委，我们一到上海就一遍一遍的背稿，改稿，想评委会提出的问题，到我们答辩的时候已经是当天晚上的最后一场了，当时评委老师已经评审了20多组作品了，已经很累了。 我们答辩的时候多的PPT因为是我们组产品经理家威做的，他个人十分喜好欧美的风格，做的APP也是全英文，做的PPT也是苹果三星风格，他也很用心的去做，我们年轻人觉得非常棒，甚至我们觉得这比赛没有人比我们的PPT做的更好的，到答辩的时候，因为教授是技术出身的，更愿意看到PPT展示跟多的技术的东西，而不是想苹果产品发布会的形式，导致减分不少，最后拿了个国赛三等奖，而软件杯这一届决赛竟然也直接缩水，决赛只有1,2等奖才能去现场赛，本来比赛本来就参赛人数多多，足足有4000多只队，进决赛的只有200多只队伍，我们那组别只有7支队能参加现场决赛角逐1,2等奖，可能是自己的作品不够优秀脱颖而出吧。 而中国高校计算机大赛移动应用创新赛因为是跟清华大学，浙江大学，苹果公司合作的缘故，就要友好的多了，虽然这些比赛的晋级率都差不多，而这个比赛就用心多了，不仅公费报销北京，杭州的沙龙，集训营，住的酒店也是4星的，送了不少纪念品，还拍了集体合照，也有很多香港，台湾那边的名校来参加比赛，全程志愿者引导，每次晋级都会告诉你评委的打分资料。 评委当时晋级比赛的打分材料，本来我还对自己的作品有点犹豫，清一色的好评让我坚信只要你的作品足够优秀，是大家都看的到的。 答辩的形式是我比较喜欢的布展答辩的形式，评委会轮流来到你的展位，你要向评委去展示你的作品，也可以去观摩别人组别的答辩，也可与自己去其他组的作品展位上了解别人的作品，每个人都很乐意向你展示他们的作品的(有一个台湾的小哥对我们的作品，来我们展台交流了很多次），我也去观摩了下别人的答辩，有不少组的答辩的表达能力是真的很强，非常自信的向评委们介绍自己的产品，一点也不怯场，我看了两场就赶紧回到自己的展位，暗自学习别人好的表他能力，不断的改进自己所要表达的内容，指导老师洪蕾老师也在用他的多年经验不断的指出我们的问题，给了我们很多的改进意见。 当我们准备的差不多的时候，评委也就来到了我们的展位，刚开始一堆评委围到我们展位时，是蛮紧张的，我们配合着视频，PPT,实机演示，一起在10分钟之内顺利的讲解完了我们的项目，评委听完我们的讲解也没有什么大的问题，而是给了我们一些建议他建议我们去用AR多实现一些路牌更多展示不了的信息，更多的路牌实现不了的功能那就很好了。 后面想想其实也是，因为这是创新赛他们可能跟愿意看到更多的创新点，虽然这个项目的想法很好，但是AR在这个项目实现的效果不是很出众，因为现阶段的所有AR的实时定位技术都不是很稳定， 最后只拿了个国赛3等奖（已经拿了3个国赛三等奖了。。。）不过前两次，我这次是看到了别人的作品的，其他组的AR作品我都去他们展位上实际了解了下，发现他们运用的技术也很简单，从创意上和技术上也比不过我们，不过他们做的比较小巧精致挺有趣的，最后有前9名逐出一，二等奖，是公开演讲答辩。 看了他们的作品，还是比较服气的，他们都是做的一个很小的切入点，然后把他实现的很完整，还有一个已经上线了一整子了，从整体UI风格，完整度，我的都要差不少，AR的作品想要实现的完整，效果好也比常规的软件难太多了，常规的软件之前大一的时候我就写过一个很完整的，而暑假每天沉迷在UE4的学习中，个人也比较喜欢游戏开发也就没怎么去迭代这个作品，没有进一度取得更好的成绩我心里也是有数的，不过我在路演前就对洪蕾老师说过我们的作品可能想要脱颖而出可能有些困难，洪蕾老师却说“没有关系，最重要是你在这个比赛中学习到多少东西”让我很感动，这些比赛，培训，以及去与其他高校学生的交流让我学到了很多。 我们组在自己的展台的合影，我个人是很喜欢这样的比赛形式的，多了很多的交流与了解 总结or经验1.做一个产品细节和完整度一定要做好，无数的细节积累打磨出来，就会产生使得用户体验做的很好2.要学会针对不同的比赛方，甲方做不同的方案，就像计算机大赛那边评委都是老教授，老教授对你的技术框架，作品的规范，完整度要求比较高，而创新比赛更加注重你的创新点3.表达能力非常重要，特别是在一个限定的时间内，怎么样去展示你的作品？展示的侧重点是什么？他们感兴趣的内容是那些？这些都是指的思考与学习的。4.参加这些比赛，还是小而精的作品更容易收到青睐，去解决一些特定人群的特定需求跟容易的得奖5.对任何技术不要惧怕，硬着头皮上，当你闷着头一直做并坚持下去的时候你会突然发现之前的一切都变简单了，比赛如此，实习亦如此。尾语 比赛与实习让我新认识了许多的小伙伴，在实习中认识了许多硬核的玩家与开发者，在比赛中有提交截止日通宵修改代码，完善作品，有一起相伴看遍北京，上海，杭州的景色，骑着小黄车在南京狂奔等等，我非常感谢互相努力的小伙伴们与指导老师们，我们一起分析需求，撰写文档，对接数据接口，修改视频，完善答辩技巧等，都是一篇绚丽的回忆，对于我来说报名参加一堆比赛的阶段已经过去了，之后也不会参加这类比赛了，我将会利用这些经验运用在之后的工作和独立游戏作品中。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
        <tag>参赛</tag>
        <tag>实习</tag>
        <tag>中国大学生计算机大赛</tag>
        <tag>中国软件杯</tag>
        <tag>移动应用创新赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EffectiveC++理解]]></title>
    <url>%2F2018%2F07%2F28%2FEffectiveC%2B%2B%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最近在看Effective C++，个人认为这是一本很好的书，因为这是一本好书，并且偏向于实际实用，看着看着里面改善程序的做法，有些特别具有实际意义，但是还有些做法都并不能理解与实际使用，就害怕像大二读《C++Primer Plus》一样花一个月死磕这本书却因为没有去实际使用体会而逐渐淡忘其中细节，所以决定慢慢的读这本书，一个条款一个条款的去领会，尽量做到领会一个条款就一直遵从这条条款去改善代码，所以这篇博客会一直更新至看完这本书为止，并会加入自己在UE4中的体会与理解，与UE4是如何遵从这些条款的案例的。 条款2：尽量用const,enum,inline替换 #define 原因是使用#deine的时候只是单纯的替换，它并不会被编译器编译，报错的时候也不会报宏的定义错误，会增加查BUG的难度，不便于程序调试。（相当于#define处于编译的规则外，想办法使它处在规则内） 关键：1.对于单纯常量，最耗以const对象或enums 或者enums代替#defines2.对于形似函数的宏（macros)，最好改用inline函数代替例如：1.将#defines 常量替换为const1#define ASPECT_RATTO 1.653 -------&gt; const double AspectRotio = 1.653 2.将#defines 常量替换为inlines函数1234567#define CALL_WITH_MAX(a,b) f((a) &gt; (b) ?(a)：(b))--------&gt;template&lt;typename T&gt;inline void callWithMax(const T&amp; a, const T&amp; b) //直接调用函数，遵守作用域和访问规则&#123; f(a &gt; b ？ a ： b);&#125; 条款3：尽可能的使用const 只要当某值不变时你就应该告诉编译器，因为告诉了它将会获得它在编译上的帮助 关键：1.关键字const出现在星号左边，表示被指物是常量，在星号右边，表示指针自身是常量2.将不需要修改的引用形参定义为const注意：const写在类型之前之后都是一样的意思12void f1(const Widget* pw);void f2(Widget const* pw); //都是指向一个不变的对象 如果想要使迭代器所指的对象不被改变，则将迭代器写为const_iterator1vector&lt;int&gt;::const_iterator iter // *iter = 10; error // iter ++; ok 条款04：确定对象被使用前已先被初始化 在对象被使用前将其初始化会减少一定的错误情况，和增加一些效率 关键1.为内置型对象进行手动初始化，即定义时进行初始化2.使用初始化列表对成员变量在构造函数中进行初始化3.因为在不同的编译单元，不知道对象的初始化次序，所以使用本地静态对象替换全局静态对象分析1.关于这条条款，我翻了一下UE4的源码，发现UE4几乎不会在定义时进行初始化，后面查阅了一下原因，可能是由于这样做会从一定程度上破坏类的抽象性，而且会增加代码编译的时间，所以可能UE4官方就没有这么做。 2.C++对象的成员变量的初始化动作发生在进入构造函数本体之前，所以在构造函数中变量的定义并不是初始化，而是赋值，成员变量在这之前就已经初始化完成了。 3.如果成员变量是const或references,那他们就一定需要在定义时进行初始化，不能被赋值。 4初始化列表以冒号开头，后跟一系列以逗号分隔的初始化字段； 1234567class foo&#123;public:foo(string s, int i):name(s), id(i)&#123;&#125; ; // 初始化列表private:string name ;int id ;&#125;; 对于内置类型，初始化表和在构造函数类初始化差别不大，但是对于类或者struct类型来说，最好使用初始化列表，因为使用初始化列表就不会调用默认构造函数，是较为高效的。所以没有默认构造函数的类类型就可以使用初始化表进行初始化。 条款05：了解C++默默编写并调用了哪些函数了解：当你创建一个类的时候，编译器会自动帮你声明一个复制构造函数，一个赋值运算符，一个析构函数，和一个默认构造函数，这些函数都是public和inline的。相关：当你声明了一个构造函数或者其他函数时，编译器就不会再为它创建默认构造函数了。 条款06：若不想使用编译器自动生成的函数，那就该明确拒绝关键：当你不想一个类被拷贝或者赋值时，你可以声明一个基类，然后将它的复制构造函数和赋值运算符声明为private,这样继承这个类之后派生类就不会玩被拷贝或者赋值了。这个基类：12345678class Uncopyabel&#123; protected: Uncopyable()&#123;&#125; ~uncopyable()&#123;&#125; private: Uncopyable(const Uncopyables&amp;); // 不写函数参数也行 Uncopyable&amp; operator=(const Uncopyable&amp;);&#125; 条款07：具有多态性质的基类应该为析构函数添加virtual 因为当删除多态的基类对象指针时，如果不为虚构函数添加virtual就不能够销毁其子类，只销毁了父类对象，会造成资源泄露 关键：1.具有多态性质的基类应该声明一个virtual虚构函数，如果类带有任何virtual函数，它就应该拥有一个virtual析构函数2.如果类不具有多态性质就不应该声明virtual析构函数相关:1.决定对象被哪一个虚函数调用的信息被一个vptr(函数地址数组指针)指出，它指向一个由函数指针构成的数组，被称为虚函数表，每一个虚函数都有这个虚函数表，当对象调用某虚函数时，编译器会在虚函数表中为该对象选取应该被调用的虚函数。2.虚函数的调用顺序：先调用最深层的派生类，最后调用父类和基类。条款8:别让异常逃离析构函数 当在使用析构函数去做一些处理的时候，不要忘记对异常进行处理 关键：1.析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞掉它们（不传播）或结束程序。2.如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。异常处理实例：1.有异常就结束程序12345678DBConn::~DBConn() &#123; try &#123; db.close(); &#125; catch (...) &#123; std::abort(); &#125;&#125; 2.吞下异常，并记录12345678DBConn::~DBConn() &#123; try &#123; db.close(); &#125; catch (...) &#123; //制作运转记录，记下对close的调用失败 &#125;&#125; 3.将异常检测作为双保险，对用户没有调用的函数，在析构函数中进行调用1234567891011121314151617181920212223242526class DBConn&#123;public: ~DBConn() &#123; if (!closed) &#123; try &#123; db.close(); //如果用户没有调用将会在析构函数中调用 &#125; catch (...) &#123; //制作运转记录，记下对close的调用失败 &#125; &#125; &#125; void close() &#123; db.close(); closed = true; &#125;private: DBConnection db; bool closed;&#125;; 条款09：绝不在构造和析构过程中调用virtual函数关键在构造和析构期间不要调用virtual函数，因为这类调用从不下降至派生类原理1.构造函数的执行顺序：先执行基类的构造函数后执行派生类构造函数 2.因为在基类构造期间，virtual不是virtual，它只会调用基类的的virtual函数，而不会调用派生类的virtual函数 3.而且在执行基类的构造函数时，派生类构造函数还没有被执行，有些变量还未被初始化，所以不允许C++执行派生类中的virtual函数 条款10：令operator=返回一个reference to *this(可以实现连锁赋值)条款11：在operator=中处理“自我赋值”关键1.确保当对象自我赋值operator=有良好行为。2.确定任何函数如果操作多个对象时，而其中多个对象时同一对象时，其行为仍然正确原因在赋值是会经常遇到“自我赋值”的情况，将对象赋值给自己，这样很容易使得自己持有一个指针指向一个已经被删除的对象，这样是十分不安全的。 12// 当i ， j 值相同时 // px 和 py指向同一地址a[i] = a[j]; // 自我赋值 *px = *py; // 自我赋值 处理常见“证同测试”：1234Widget&amp; Widget::operator(const Widget&amp; rhs)&#123; if(this = &amp;rhs) return *this; //如果是自我赋值，就不做任何事&#125; 除此之外还有“异常处理”，copy and swap技术等不同的处理 条款12：复制对象时勿忘其每一个成分关键 复制函数应该确保复制所有local变量 不要尝试以某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数，并由两个coping函数共同调用。 注意:1.当你为class添加一个成员变量，你必须同时修改复制函数 2.当你为派生类写复制构造函数时，因为父类的成员有些可能是private成员，所以无法直接访问，所有要调用相应的父类函数获取父类成员 条款13：以对象管理资源 所谓资源就是，一旦用了它，将来必须还给系统 关键1.为了防止资源泄露，应该使用智能指针去管理资源，因为他们会在自动去调用析构函数，释放资源说明1.单纯靠用户去调用delete语句是行不通的，因为这也不一定保证资源被释放。 2.智能指针管理对象时一旦对象被销毁或者对象离开作用域时，其析构函数会被自动调用，于是资源被释放。 3.当使用auto_ptr时，如果进行复制和赋值操作，那么被复制物会被置NULL，因为auro_ptr保证资源的唯一拥有权。 4.智能指针的底层是使用引用计数管理资源，用于追踪有多少对象指向某资源，并在无人指向它时自动删除该资源。不同于垃圾回收，引用计数并不能解决循环引用。 条款14:在资源管理类中小心Copying行为 应该根据不同的资源行为与需求定义不提供的复制行为 关键1.复制RAii对象必须一并复制它所管理的资源，资源的copying行为决定RAII对象的copying行为。2.普通常见的RAII class copying行为有：禁止复制，使用引用计数，复制底部资源，转移资源的拥有权说明1.禁止复制很多时候RAII不应该被复制。 2.对底部资源使用引用计数3.可以对其进行深拷贝，拥有任意数量的副本4.希望只有一个未加工资源（raw recource),复制时将资源的拥有权转移给目标对象。（auto_ptr就是这样做的）条款15：在资源管理类中提供对原始资源的访问 使用智能指针管理资源虽然挺好，但是有时候会直接访问原始资源（普通指针）的需求，这是后就会产生一些问题 关键1.有时候有访问原始资源的需求，所以应该为其提供取得其所管理资源的方法 2.对原始资源的访问可能经由显式转换成隐式转换，一般而言显式转换比较安全，当隐式转换对客户比较方便。 解释需要进行转换的例子：1234std::tr1::shared_ptr&lt;Investment&gt; pInv(createInvestment()); int daysHeld(const Investment* pi); int days = daysHeld(PInv) //错误的调用 编译不通过，是因为deysheld需要的是Investment* 指针，你传递给它的却是个trl::shared_ptr对象 这时候就需要进行转换，一般有显式转换和隐式转换显式转换1234567class Font&#123;&#123;public: FontHandle get() const &#123;return f&#125;;private: FontHandle f;&#125; 隐式转换12 条款16：成对使用new和delete时要采取相同形式关键如果你在new表达式中使用[],必须在相应的delete表达式中也使用[].如果你在new表达式中不使用[],一定不要在相应的delete表达式中使用[]原因12delete stringPtr1; //删除一个对象delete [] stringPtr2; //删除一个由对象组成的数组 如果不加括号，delete认定指针指向单一对象，加括号之后之后只能认定指针指向一个数组 条款17：以独立语句将newed对象置入智能指针 创建智能指针时应该以单独的语句进行声明，而不是在函数调用是进行声明 关键以独立语句将newed对象存储于智能指针内，如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露问题当编译器：执行“”new Widget“” –&gt;调用prioruty–&gt;trl::shared_otr构造函数次序时，如果对priority函数调用异常，则newWidget返回的指针会遗失，因为它尚未被置入shared_ptr内。 1processWidget(std::trl::shared_ptr&lt;Widget&gt;(new Widget), priority()); 因为priority()调用的顺序是不定的 解决：分离语句12std::trl::shared_ptr&lt;Widget&gt;(new Widget);processWidget(pw, priority()); 设计与声明条款18：让接口容易被正确使用，不易被误用 一个没有考虑全面的接口很容易被用户错误的使用 关键1.你应该在你的所有接口中努力达成容易被正确使用，不容易被误用的目标2.促进正确使用：1.保证接口的一致性 2.使得内置的类型一致3.阻止误用：1.通过建立新的类型，然后去限制用户对类型上的操作 2.束缚对象值的范围 3.消除客户的资源管理责任4.智能指针shared_ptr支持定制删除器，这可以防止DLL问题（不同动态链接库销毁指针问题），可以被用来自动解除互斥锁。常见用户错误的使用与预防问题：输入数据类型的不正确？解决：1.将要输入的类型用struct或者函数进行封装，然后对其调用 2. 限制输入的类型问题：用户没有删除指针或者删除已经删除过得指针？解决：使用智能指针对其资源进行管理问题：用户忘记使用智能指针？解决：接口设计时就先发制人，令函数返回一个指针指针，这样用户就必须使用指针指针了问题：用户想要对智能指针下的原始指针进行delete，企图使用错误的资源析构机制？解决：在接口设计时，令函数返回一个绑定删除器函数的智能指针，这样用户就只能去销毁智能至指针而不是原始指针了条款19：设计class犹如设计type 在设计一个类时应该考虑的问题 关键当你定义了一个新的class，你应该严谨来考虑class的设计，尝试着回答下面几个问题： （1）新type的对象该如何被创建和销毁？ （2）对象的初始化和赋值该有什么区别？ （3）新type对象如果被“值传递”会发生什么？ （4）什么是新type的合法值？ （5）你的新type需要配合某个继承体系吗？ （6）你的新type需要什么样的转换？你的类对象转换为其他对象或者其他类型对象隐式或显式转换为你的对象。 （7）什么样的操作符和函数对此新type是合理的？ （8）什么样的标准函数应该驳回？ （9）谁该取用新type成员？ （10）什么是新type的“未声明接口”？ （11）你的新type有多么一般化？你是定义一个class还是一个新的class template？。 （12）你真的需要一个新的type吗？ 这些问题都是十分细节的，不好回答的，但是这种在类设计前就对类进行全面思考的思维是指的学习的 条款20：宁以pass-by-reference-to-const替换pass-by-value 函数类对象传参时引用传递要比值传递效率高 关键函数参数传递的时候，如果参数是内置类型使用值传递，如果是自定义类型就使用引用传递说明1.对于自定义类型而言，引用传递比值传递效率搞。例如有参数是继承的函数中，值传递会调用6次构造函数和6次析构函数，而对于引用传递，没有任何新对象被创建，没有调用任何析构函数和构造函数！从这才知道值传递对于引用传递的效率之差这么大2.如果函数中不对参数进行修改，应该定义为const类型3.引用传递还会解决函数“切割”问题（如果在值传递一个派生类，那么派生类将会变成基类，而没有多态性质）UE4中的使用 在UE4的源码中也遵守者这条条款，但却做了一些改变，UE4中基础数据对象使用值传递，继承自UObject的类使用指针传递（实质上是值传递），大概是UE4官方对UObject类做了一些优化吧，F开头和自定义的类都使用引用传递参数。 条款21：必须返回对象是，别妄想返回其reference 在程序中不能玩盲目的返回引用 关键 不要返回一个指向局部变量的指针或者引用；不能返回一个指向heap_allocated对象的引用； 原因 1.因为局部变量在函数退出前就被销毁了 2.在堆中没有合理的方法让operator* 使用者进行delete调用 条款22：将成员变量声明为private 在成员变量声明的时候应该考虑变量将会被谁使用 关键1.切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的弹性。2.protected并不比public更具封装性。原因1.接口一致2.精准的访问控制3.良好的封装性，可以使得当我们改变这个成员的时候不会影响太多的代码，客户也不会知道类中的变化。条款23：宁以non-member、non-friend函数替换member函数 当要调用一个类的多个函数时，应该声明为非成员函数，主要从封装性考虑 关键宁可拿non-member non-friend函数替换member函数.这样做可以增加封装性,包裹弹性和机能扩充性。解释如果只是单纯的调用函数，那么就应该使用非成员函数去调用成员函数7，因为成员函数能够访问类中的私有成员，封装性比非成员函数要低条款25：考虑写出一个不抛出异常的swap函数 swap的使用很多时候是效率不高的，这个条款可以使得swap函数变得效率高 关键当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常细节1.常规的置换将会创建3个原来对象和三个指针对象，效率低，效率很低，实际上，我们只用置换指针的指向就行了。12345678namespace std &#123; template&lt;&gt; void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123; swap(a.pImpl, b.pImpl); //交换指针值 &#125;&#125; 2.我们不能修改std命名空间的任何东西，所以我们要声明一个非成员函数去调用成员函数123456789class Widget&#123;public: void swap(Widget&amp; other) &#123; using std::swap; // 调用成员函数 swap(pImpl, other.pImpl); &#125;&#125;; 这就实现了对swap交换指针的优化 条款31：将文件的编译依存关系降至最低 单例对某个类进行修改时，如果不将编译的依存关系降至最低，那将会基本重写编译和连接，将会大大影响开发效率 关键1.为声明和定义提供不同的文件2.依赖于声明式不依赖与定义式说明在UE4中我们平时写代码就已经习惯性将声明和定义分开了，所以可以不用注意这部分，所以需要注意的是：要尽量使用”Class外部声明”代替”#include包含”，这样做的优点是可以不用去编译多余文件 class外部声明使用： 1.在AB类之间相互引用时使用class外部声明 2.在类中只需要其他类的引用而不需要其内部的定义，变量，方法时使用 例如 123456789#include &quot;StrategyGameMode.generated.h&quot;class AController;UCLASS(config=Game)class AStrategyGameMode : public AGameModeBase&#123; GENERATED_UCLASS_BODY()&#125; UE4中特定的条款1.自己创建的非继承自UObject的类尽量使用智能指针TSharedPtr/TsharedRef来进行管理 如果你的純C++類是使用new來分配內存，而且你直接傳遞類的指針，那麼你需要意识到：除非你手动删除，否则这一块内存将永远不会被释放，如果忘记了，会造成内存泄露，如果使用智能指针会使用引用技术来完成自动的内存释放。 关键：注意：TSharedPtr与UObject是互不兼容的，UObject会自动加入GC标记例如1.自己定义的Struct结构体1TSharedPtr&lt;FActionButtonInfo&gt; GetActionButton(int32 Index) const; 2.自己定义的类1TSharedPtr&lt;class SStrategySlateHUDWidget&gt; GetHUDWidget() const; 3.结合使用12TSharedPtr&lt;TArray&lt;class FStrategyMenuItem&gt;&gt; MainMenu; //一组自定义类TArray&lt;TSharedPtr&lt;TArray&lt;class FStrategyMenuItem&gt;&gt;&gt; MenuHistory; //自定义类数组引用的数组]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Effective</tag>
        <tag>C++</tag>
        <tag>程序优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4反射系统与序列化整理]]></title>
    <url>%2F2018%2F05%2F23%2FUE4%E5%8F%8D%E5%B0%84%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是UE4反射？在UE4里面，你无时无刻都会看到类似UFUNCTION（）这样的宏。官方文档告诉你，只要在一个函数的前面加上这个宏，然后在括号里面加上BlueprintCallable就可以在编辑器里面调用了。按照他的指示，我们就能让我们的函数实现各种各样特别的功能，那这个效果就是通过UE4的反射系统来实现的。这看起来确实非常棒，不过同时给UE4的反射系统增添了一点神秘感。我们可能一开始尝试着去找一下这个宏的定义，但是翻了几层发现没有头绪，可能也就懒得再去研究他是怎么实现的了。 其实，所谓反射，是程序在运行时进行自检的一种能力，自检什么呢？我认为就是检查自己的C++类，函数，成员变量，结构体等等（对应起来也就是大家在UE4能看到的UCLASS，UFUNCTON，UPROPERTY，USTRUCT后面还会提到）。 C++本来是不支持反射的，只有一个基本的RTTI（运行时类型信息）特性，仅能在运行时获取对象的类型信息，无法得到成员变量和函数列表信息。如果我们要对成员变量进行序列化（存档/读档），需要自己写很多辅助的读取和写入方法，非常麻烦。反射就是，运行时获取成员变量，成员函数等的机制 UE4在C++编译开始前，使用工具UnrealHeaderTool，对C++代码进行预处理，收集出类型和成员等信息，并自动生成相关序列化代码。然后再调用真正的C++编译器，将自动生成的代码与原始代码一并进行编译，生成最终的可执行文件。这个过程类似于Qt的qmake预处理机制。 UCLASS :类,告诉UE4生成类的反射数据。类必须派生自 UObject，如果你的类继承自UObject,需要在类名上方加 UFUCTION: 函数,使 UCLASS 或 USTRUCT 的类方法可用作 UFUNCTION。UFUNCTION 允许类方法从蓝图中被调用，并在其他资源中用作 RPC。(包裹功能) UPROPERTY: 成员, 使 UCLASS 或 USTRUCT 的成员变量可用作 UPROPERTY。UPROPERTY 用途广泛。它允许变量被复制、被序列化，并可从蓝图中进行访问。垃圾回收器还使用它们来追踪对 UObject 的引用数。（包裹属性） USTRUCT: 变量 USTRUCT：结构体,告诉UE4生成结构体的反射数据（包裹结构） UENUM()：告诉UE4生成枚举的反射数据 GENERATED_BODY() - UE4 使用它替代为类型生成的所有必需样板文件代码 那检查这些东西做什么呢？最明显的就是支持蓝图和C++的交互功能，说的更通俗一点，就是可以更自由的控制这些结构，让他在我们想出现的地方出现，让他在我们想使用的地方使用。要知道我们在虚幻4中声明的任意一个类，都是继承于UObject类的，所以他远远不是我们所以为的那个普通的C++类。我们可以使用这个类进行网络复制，执行垃圾回收，让他和蓝图交互等等。而这一切原生的C++是并不支持的，也正是因此虚幻4才构建了一个这样的反射系统。 反射一般用于哪些地方？在UE4里面， 基本上所有的游戏工程的类都需要用到。比如，你用编辑器新建一个类，类的前面会自动添加UCLASS()；新建一个结构体，需要使用USTRUCT()；新建一个枚举变量，需要在前面声明UENUM()；在类的里面，也必须要加上GENERATED_UCLASS_BODY()才行。 如果你的类继承自UObject,的的类名上方需要加入UCASS()宏，同时需要在类体的第一行添加GENERATED_UCLASS_BODY宏，或者GENERATED_BODY()宏， 如果是GENERATED_UCLASS_BODY，则需要手动实现一个带有const FObjectInitializer&amp;参数的构造函数， 如果是GENERATED_BODY()则需要手动实现一个无非参数构造函数 如果你想让你的变量能显示在编辑器里面，想让你的函数可以被蓝图调用或者通过让这个函数实现RPC网络通信功能，或者你想让你的变量被系统自动的回收，这些都离不开反射系统以及这些宏定义。 所以，我们这里起码能认识到，在网络通信，蓝图交互以及垃圾回收方面，这与反射系统是密不可分的。 序列化 序列化是将一个对象变为更已保存的形式，写入到持久储存中，反序列化则相反，从持久储存中读取数据，然后还原原先对象 有了反射功能之后，成员变量的序列化也就更方便了。UE4收集了每个类成员的类型信息，这样存档和读档时，根据名称和类型就可以自动完成了，整个过程不需要人工干预。 需要序列化的成员变量，需要在变量声明的时候在前面加上UPROPERTY()宏，宏参数有很多，分别表示变量的详细属性，下面列举一些常用的： UPROPERTY参数 说明 EditAnywhere 表示该属性可从编辑器内的属性窗口编辑。 Category 定义属性的分类。使用方法: Category=CategoryName. （分类=分类名称） Const 编辑器中不能修改该值 BlueprintReadOnly 在蓝图中只读，不可修该。 BlueprintReadWrite 在蓝图中可读写。 BlueprintCallable 仅能用于Multicast代理。该代理可被蓝图调用。 VisbleDefaultsOnly： 属性只在archetype蓝图中修改 与UPROPERTY对应的还有一个用于修饰函数的宏UFUNCTION，该宏常用于描述如何从蓝图中访问C++的函数。 UFUNCTION参数 说明 BlueprintCallable 这种类型的函数，只能在C++中实现和重写。可以理解为蓝图“只读”函数。 BlueprintImplementableEvent 只能在蓝图中实现的函数。类似于C++的纯虚函数 BuleprintNativeEvent 都可以用（需要提供一个“函数名_Implement”为名字的函数实现，放置与.cpp Exec 控制台调用 BlueprintAssignable 暴露该属性来在蓝图中进行分配赋值 实例:1UFUNCTION(BlueprintCallable,Category = &quot;Sanwu|TestFuncLib&quot;) Category是函数的分类，点击鼠标右键会打开上下文菜单，“SanWu|TestFunLib”的意思是指Say Hello函数放在sanwu分类下的Test Func Lib类目下 类修饰符（UCLASS）： abstract（抽象）： 将类声明为抽象基类，这样会阻止用户实例化这个类。 advancedclassdisplay（高级显示）： 强制类的所有属性仅在Details面板中的高级选项中显示，并且默认为隐藏。 autocollapsecategories（自动隐藏分类）： 取消在父类上使用AutoExpandCategories修饰符的列出分类效果。 autoexpandcategories（自动展开分类）： 为这个类的对象指定应该在虚幻编辑器属性窗口中自动展开的一个或多个类别。要自动展开没有声明类别的变量，请使用声明这个变量的类的名称。 blueprintable（蓝图可接受）： 指定该类为创建蓝图的可接受基类。除非被继承，否则默认值为NotBlueprintable。它由子类继承。 blueprinttype（蓝图的类型）： 此类可作为蓝图中的一种变量类型使用。 classgroup（类组）： 表示虚幻编辑器的Actor浏览器在Actor浏览器中启用GroupView的时候应该在指定的GroupName中包括这个类及其所有子类。 collapsecategories（类组）： 表示这个类的属性不应该归类在虚幻编辑器属性窗口的类别中。这个关键字被传递给子类，但子类可以使用DontCollapseCategories关键字覆盖这个标志。 config（配置）： 表示允许这个类在配置文件(.ini)中存储数据。 如果在这个类中有任何可配置的变量（使用 config 或 globalconfig变量修饰符进行声明），这个修饰符会将这些变量存储在 ( 和 ) 内的指定配置文件中。 将这个标志传递给所有子类，而且无法否定这个标志，但是子类可以通过重新声明config 关键字并指定一个不同的文件名来更改这个.ini文件。 将 IniName 的值添加到游戏名称后面 - 减去 “Game” 部分 - 指定要存储数据的.ini文件的名称（例如，在 UDKGame 指定config(Camera)将会使这个类使用UDKCamera.ini 文件）。 还可以将关键字inherit指定为 IniName ，这样做会使得这个类使用与它的父代相同的配置文件。 默认情况下，会有一些 .ini文件，例如：Config=Engine: 使用 引擎 配置文件，也就是您的游戏名称后面加上Engine.ini。 例如，UDKGame 的引擎配置文件的名称是UDKEngine.ini。Config=Editor: 使用 编辑器 配置文件，也就是您的游戏名称后面加上Editor.ini。 例如，UDKGame 的编辑器配置文件的名称是 UDKEditor.ini 。Config=Game: 使用 游戏 配置文件，也就是您的游戏名称后面加上Game.ini。 例如，UDKGame 的游戏配置文件的名称是 UDKGame.ini 。Config=Input: 使用 输入 配置文件，也就是您的游戏名称后面加上Input.ini。 例如，UDKGame 的引擎配置文件的名称是UDKInput.ini const（常量）： 本类中的所有属性及函数均为常量，并应作为常量导出。该标识由子类继承。 conversionroot（根转换）： 根转换限制子类转换，使其仅能转换为其上等级的首个根类的子类。 customconstructor（自定义构造函数）： 防止构造函数声明的自动生成。 defaulttoinstanced（默认实例化）： 该类中所有实例都被视为”已进行实例化”。已进行实例化的类（组件）在构建时被复制。该标识由子类继承。 dependson（依赖）： 表示 ClassName 是在这个类之前进行编译的。 ClassName 必须在同一个（或者是以前的）软件包中指定一个类。多个依赖的类可以通过使用一个单独的DependsOn代码行并且类之间通过逗号分界来指定，或者通过为每个类使用单独的DependsOn行来指定。这在类使用一个在其他类中声明的结构体或枚举变量时非常重要，因为编译器只知道在它已经编译的类中都有些什么。 deprecated（弃用）： 该类已被废弃，并且该类的对象在序列化时将不会被保存。该标识由子类继承。 dontautocollapsecategories（取消自动隐藏分类）： 取消从父类继承的特定目录的AutoCollapseCategories关键字。 dontcollapsecategories（取消类组）： 取消从基类继承的CollapseCatogories关键字。 editinlinenew（可新建）： 表示这个类的对象可以通过虚幻编辑器属性窗口进行创建（默认的操作是只引用可以通过属性窗口进行分配的现有对象）。这个标志将被传递给所有子类，子类可以使用 NotEditInlineNew 关键字覆盖这个标志。 hidecategories（隐藏组）： 为这个类的对象指定应该隐藏在虚幻编辑器属性窗口中的一个或多个类别。要隐藏没有声明类别的变量，请使用声明这个变量的类的名称。这个关键字被传递给子类。 hidedropdown（在组合框中隐藏）： 禁止这个类显示在虚幻编辑器属性窗口组合框中。 hidefunctions（隐藏函数）： 将指定函数隐藏在属性视图中。 intrinsic（原生）： 类直接在C++中进行声明，并且不具有由UnrealHeaderTool生成的样板文件，不要在新类上使用此标识。 minimalapi（精简）： 使得类的类型信息由其他模块导出以供使用。这个类可以被投射，但类的函数无法被调用（除了内联方式）。这样可以改善对不需要其所有功能在其它模块进行调用的类的编译时间。 noexport（不导出）： 表示这个类的声明不应该包含在头文件编译器自动生成的 C++ 头文件中。该 C++ 类声明必须在单独的头文件中手动进行定义。只对 native 类有效。 nontransient（取消临时）： 取消从基类继承的Transient关键字。 notblueprintable（非蓝图接受）： 指定该类不是创建蓝图的可接受基类。除非被继承，否则默认值为NotBlueprintable。它由子类继承。 notplaceable（不可放置）： 否定从基类继承的Placeable关键字。表示在虚幻编辑器中不可以将这个类放置到关卡等位置。 perobjectconfig（配置每个对象）： 这个类的配置信息将会根据对象进行存储，其中每个对象在.ini文件中都有一项，它以这个对象的名字命名，格式为[ObjectName ClassName]。此关键字被传递到子类。 placeable（可放置）： 表明该类可在虚幻编辑器内进行创建并被放置在关卡，UI场景，或蓝图内（取决于该类类型）。此标识被传递到所有的子类中，子类可使用 NotPlaceable 关键字来重载该标识。 showcategories（显示组）： 否定从基类继承的特定分类的 HideCategories 关键字。 showfunctions（显示函数）： 在属性视图中显示指定的函数。 transient（显示函数）： 也就是“属于这个类的对象永远不应该保存在磁盘上”。仅在与本身为非持续的native类的特定种类结合使用时有用。这个关键字被传递给子类，子类可以使用NonTransient关键字覆盖这个标志。 within（包含）： 表明此类的对象不能存在于 ClassName 的实例 之外 。 为了创建这个类的对象，您必须将 ClassName 的实例指定为 Outer 对象。 函数修饰符（UFUNCTION）： blueprintauthorityonly（蓝图仅有权限执行）： 如无网络权限，则该函数将不会从蓝图代码中执行。 blueprintcallable（蓝图可执行）： 该函数可在蓝图或关卡蓝图图表内执行。 blueprintcosmetic（蓝图修饰）： 此函数为修饰函数而且无法运行在专属服务器上。 blueprintimplementableevent（蓝图重载事件）： 此函数可以在蓝图或关卡蓝图图表内进行重载。 blueprintnativeevent（同时事件）： 此函数将由蓝图进行重载，但同时也包含native类的执行。提供一个名称为[FunctionName]_Implementation的函数本体而非[FunctionName];自动生成的代码将包含转换程序,此程序在需要时会调用实施方式。 blueprintpure（蓝图可执行纯净）： 此函数不会以任何方式影响其从属对象，并且可在蓝图或关卡蓝图图表中执行。 category（分类）： 当在蓝图编辑工具中显示时，定义函数的分类。 client（客户端）： 此函数仅在该函数从属对象所从属的客户端上执行。提供一个名称为[FunctionName]_Implementation的函数主体，而不是[FunctionName]; 自动生成的代码将包含一个转换程序来在需要时调用实现方法。 customthunk（自定义转换）： UnrealHeaderTool（虚幻头文件工具）的代码生成器将不会为此函数生成execFoo转换程序; 可由用户来提供。 exec（执行）： 此函数可从游戏中的控制台中执行。Exec命令仅在特定类中声明时才产生作用。 netmulticast（网络所有执行）： 无论Actor的NetOwner为何值，此函数都会在服务器上被本地执行且将被复制到所有的客户端。 reliable（可靠）： 此函数在网络间进行复制，并会忽略带宽或网络错误而被确保送达。仅在与客户端或服务器共同使用时可用。 server（服务器）： 此函数仅在服务器上执行。提供一个名称为[FunctionName]_Implementation的函数主体，而不是[FunctionName]; 自动生成的代码将包含一个转换程序来在需要时调用实现方法。 unreliable（不可靠）： 此函数在网络间复制，但可能会由于带宽限制或网络错误而传送失败。仅在与客户端或服务器一起使用时有效。 元数据修饰符（meta=）： blueprintinternaluseonly（仅内部实现）： 此函数为内部实现细节，被用来实现另一个函数或节点。它从不在图表中直接展现。 blueprintprotected（受保护）： 此函数仅能在蓝图中针对‘此’实例进行调用。无法针对另一个实例进行调用。 blueprintspawnablecomponent（蓝图可生成）： 如有该类修饰符，此组件类可由蓝图来生成。 connotimplementinterfaceinblueprint（蓝图不可实现接口）： 该接口无法通过蓝图来实现（比如，它仅有不显示的C++成员方式）。 deprecatedfunction（启用的函数）： 该函数被废弃，任何引用它的蓝图都会产生一个编译警告。 deprecationmessage（启用信息）： 提供废弃函数的自定义信息。 unsafeduringactorconstruction（构造函数调用不安全）： 属性修饰符（UPROPERTY）： advanceddisplay（高级选项）： 属性被显示在细节面板的高级下拉框中。 assetregistrysearchable（资源可注册）： 表明此属性及其值将会为任意将其作为成员变量而包含的资源类示例被自动添加到资源注册中。不可用于结构体属性或参数。 blueprintassignable（蓝图分配）： 仅能用于Multicast代理。应显示该属性，以供在蓝图中分配。 blueprintcallable（蓝图可调用）： 仅能用于Multicast代理。应显示该属性，以在蓝图代码中调用。 blueprintreadonly（蓝图仅可读）： 蓝图该属性仅可读取。 blueprintreadwrite（蓝图可读写）： 蓝图该属性仅可读写。 category（分类）： 定义属性的分类。 config（可配置）： 表示该变量将会成为可配置状态。当前值可被保存到ini文件中，并且将在创建时被载入。无法在默认属性中被赋值。只读。 const（常量）： 定义属性为常量。 duplicatetransient（复制重置）： 表示变量值应在任意类型的重复过程中（复制/粘贴，二进制文件复制等）被重置为类默认值。 editanywhere（可编辑）： 表示该属性可从编辑器内的属性窗口编辑。 editdefaultsonly（仅对原型编辑）： 表示该属性可通过属性窗口来编辑，但仅能对原型编辑。 editfixedsize（固定大小）： 仅限于动态数组。这使得用户不能通过UnrealEdtor属性窗口来变更数组的长度。 editinline（可编辑引用）： 通过此修饰符使得用户可编辑UnrealEd的属性查看器中的变量所引用的对象属性。（仅对对象引用可用，包括对象引用数组）。 editinstanceonly（仅对实例编辑）： 表示该属性可通过属性窗口来编辑，但仅能对实例而非原型进行编辑。 export（导出）： 仅对对象属性（或对象数组）有效。表示当对象被复制（复制/粘贴）或导出到T3D时，被分配给该属性的对象应完全作为子对象区块来导出，而不是仅仅输出对象引用本身。 globalconfig（全局配置）： 类似于config修饰符，区别是您不能在子类中重载它。无法在默认属性中被赋值。 只读。 instanced（实例化）： 仅能用于对象属性。当此类的实例被创建时，它会被赋予一个默认分配给此变量的对象的独特拷贝。用于对在类默认属性中定义的子对象进行实例化。类似EditInline和Export修饰符。 interp（演出）： 表示该值可由Matinee的浮点或向量属性轨迹来随时间驱动。 localized（本地）： 此变量的值将定义本地值。最常用于字符串。只读。 native（原生）： 属性为native:C++代码负责对其序列化并显示给GC。 noclear（非空）： 防止该对象引用在编辑器中被设置为None.隐藏编辑器的清除（以及浏览）按钮。 noexport（不可导出）： 仅对native类有效。此变量不应被包含在自动生成的类声明中。 nontransactional（不可撤销重做）： 表示变更为此变量值将不会被包含在编辑器的撤消/重做历史中。 ref（参考）： 该值在函数调用后被复制出来。仅在函数参数声明中有效。 replicated（网络复制）： 此变量应通过网络进行复制。 replicatedusing（网络复制执行）： 此变量应通过网络进行复制，在其接受到 Callback 函数后执行。 repretry（网络重复复制）： 仅用于结构体属性。如无法被完全发送，请重试复制此属性（例如，对象引用尚无法通过节点网络来进行序列化）。对于简单引用来说，这是一个默认值，但对结构体来说，由于带宽消耗，很多情况下我们不需要。所以除非此标识被定义，否则其会被禁用。 savegame（保存游戏）： serializetext（序列化为文本）： Native属性应以文本形式进行序列化（导入文本，导出文本）。 simpledisplay（显示）： 使属性在细节面板中默认为可见。 transient（临时）： 该属性为临时属性。不应被保存，在载入时会被填零。 visibleanywhere（全可见）： 表示该属性在属性窗口中可见，但根本无法被编辑。 visibledifaultsonly（默认中可见）： 表示该属性仅在原型的属性窗口中可见，但无法被编辑。 visibleinstanceonly（仅实例可见）： 表示该属性仅在实例的属性窗口中可见，但对原型则不行，并且无法被编辑。 结构体修饰符（USTRUCT）： atomic（单元）： 意味着这个struct要一直作为一个单独的单元进行序列化。 blueprinttype（蓝图类型）： 将此结构体作为用于蓝图中变量的类型。 immutable（不可变）： 仅可在Object.h中使用，而且正逐步淘汰，请不要在新的结构体上使用！。 noexport（不导出）： 不会为该类创建自动生成的代码；标头只用于解析元数据。]]></content>
      <categories>
        <category>UE4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>反射</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity中反编译脚本代码与提取游戏资源]]></title>
    <url>%2F2017%2F12%2F23%2FUnity%E4%B8%AD%E5%8F%8D%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%8F%90%E5%8F%96%E6%B8%B8%E6%88%8F%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[在Unity的脚本代码的学习之中，我们除了通过看教程中的脚本演示，Unity博客，论坛，知识板块等网站的学习,还可以通过看已上线的游戏的源码，通过这种看已上线游戏源码方式的优点在于相比上述的方式要更加的规范，深入，全面（毕竟是已完成的游戏）,当我们缺少优质素材用于练习时我们也可以通过提取游戏资源的方式，提取你想要的风格的游戏资源，这将会大大方便我们在学习游戏开发中的进程。 1.Unity中反编译脚本代码1.1 、反编译工具dnSpy 是一款针对 .NET 程序的逆向工程工具,基于 ILSpy 发展而来的 .net 程序集的编辑，反编译，调试神器。。该项目包含了反编译器，调试器和汇编编辑器等功能组件，而且可以通过自己编写扩展插件的形式轻松实现扩展。该项目使用 dnlib 读取和写入程序集，以便处理有混淆代码的程序（比如恶意程序）而不会崩溃。 1.2、Unity源码文件位置unity的源码都存放在dll中，那么反编译的工作就是把从dll 中提取出源码，基本上我们的代码都在Assembly-CSharp.dll这个文件中 1.3、破解Unity源码文件 将Assembly-CSharp.dll文件拖动到dnspy反编译工具中就实现了破解 我用一个的独立游戏做的示例： 上图可以看出反编译出了编码者完整的代码逻辑 2.提取游戏中的资源 游戏中的美术资源没法完全加密，即便使用特别复杂的加密方式，也有办法将其中的资源提出来,这里只借助现成的工具，做些浅显的资源提取。 2.1、资源提取工具 相比于Disunity与UnityAssetsExplorer工具，UnityStudio 拥有可视化界面，可以批量导出贴图，模型，字体，音频等，可以预览，最新版支持Unity5.x，所以在这使用UnityStudio作为资源提取工具。 2.2、下载地址 https://github.com/Perfare/UnityStudio 2.3、Unity中资源位置 点击菜单 File 中的“Load folder…”，载入 unity 游戏的 Assets -&gt; bin -&gt; data 文件夹。也可以选择“Load file…”，载入 .unity3d 或者 .boundle ，.assets文件。 2.4、预览资源 选择 Assets List，可以看到里面有很多资源文件。点击即可在右侧窗口进行预览，可以预览贴图，Shader，模型的资源,还可以直接播放音频。 2.5、保存资源 选中需要的资源，点击菜单工具栏里的 Export -&gt; Selected assets，即可将选中的资源保存到本地。 用一个的独立游戏做的示例： 上图中在seneHierarghy界面中可以查看资源的结构目录，资源中的音乐文件都可以直接播放测试，在右边的视图中可以使用wsad将对模型进行旋转查看 其他相关博客：如何避免代码被反编译 ： http://www.xuanyusong.com/archives/2664Unity3d 反编译破解游戏 简单示例: http://blog.csdn.net/huutu/article/details/46573327)]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>反编译</tag>
        <tag>脚本</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity 动画插件DoTween]]></title>
    <url>%2F2017%2F12%2F08%2FUnity%E5%8A%A8%E7%94%BB%E6%8F%92%E4%BB%B6DoTween%2F</url>
    <content type="text"><![CDATA[DoTween Pro是一款untiy插件，是untiy中最好用的tween插件，实现脚本和视觉脚本的新功能，支持包括移动，淡出，颜色，旋转，缩放，打孔，摇动，文本，相机属性等，DoTween与其他动画插件相比，它的效率是最高，支持支持可视化编程。 1.DoTween中数值的曲线变化 数值从一个固定值变化到另一个固定值，变化速度先快后 123456789101112131415161718192021222324252627282930using System.Collections;using System.Collections.Generic;using UnityEngine;using DG.Tweening; //引入标准库public class move : MonoBehaviour &#123;/** 接收物体 */public Transform cubeTransform;/** 创建一个位置信息 */public Vector3 Value = new Vector3(0, 0, 0);/** 创建一个面板信息 */public RectTransform taskpanelTransform;void Start () &#123;/*** 用动画的方式改变变量的值(通过差值的方式去修改一个值的变化)：变化成曲线进行，先快后慢* @param ()=&gt; - 指定一个目标* @param x=&gt; - 给x的系统值赋值* @param Vector3 - 目标位置* @param 2 -移动到目标位置需要的时间*/DOTween.To(() =&gt; Value, x =&gt; Value = x, new Vector3(10, 10, 10), 2);&#125;void Update () &#123;//把cubeValue的值赋给物体cubeTransform.position = Value;taskpanelTransform.localPosition = Value;&#125;&#125; 能实现的功能：1.游戏物体的移动 2.UI面板的移动 UI面板移动代码优化： 12345public RectTransform panelTransform;public void OnClick()&#123;panelTransform.DOLocalMove(new Vector3(0, 0, 0), 0.5f);&#125; 3.动画的倒放12345678910111213141516171819202122232425262728293031using System.Collections;using System.Collections.Generic;using UnityEngine;using DG.Tweening;public class ButtonClick : MonoBehaviour &#123;public bool isIn = false;public RectTransform panelTransform;void Start()&#123;Tweener tweener = panelTransform.DOLocalMove(new Vector3(0, 0, 0), 0.5f);//默认播放完动画就销毁了/** 创建一个Tweener对象保存这个动画的信息 */tweener.SetAutoKill(false); // 把自动销毁动画设置为falsetweener.Pause();&#125;public void OnClick()&#123;if (isIn == false)&#123;panelTransform.DOPlayForward(); // 前放（与back是一对)isIn = true;&#125;else&#123;/** 使面板离开视野 */panelTransform.DOPlayBackwards(); //倒放之前的动画isIn = false;&#125;&#125;&#125; 实现: 2.常规设置1.设置动画播放曲线123Tween tweener = transform.DOLocalMoveX(0, 5);// -------设置动画的播放曲线tweener.SetEase(Ease.InBounce); 不同的曲线类型（缓动函数）： 2.设置动画的循环次数1tweener.SetLoops(1); 3.设置动画事件函数123456tweener.OnComplete(OnTweenComplete);void OnTweenComplete()&#123;Debug.Log(&quot;完成&quot;);&#125; 动画事件函数有： OnComplete(TweenCallback callback) 动画播放完成时调用OnKill(TweenCallback callback) 动画被销毁时调用OnPlay(TweenCallback callback) 动画播放时调用（可被调用多次）OnPause(TweenCallback callback) 动画暂停时被调用OnRewind(TweenCallback callback) 动画被重置时调用OnStart(TweenCallback callback) 动画刚开始播放时被调用(只会被调用一次)OnStepComplete(TweenCallback callback) 动画完成一个循环时被调用OnUpdate(TweenCallback callback) 动画被更新时被调用OnWaypointChange(TweenCallback callback 动画改变时被调用 文字的播放12345private Text text;void Start () &#123;text = this.GetComponent&lt;Text&gt;();text.DOText(&quot;恭喜你挑战成功，我们即将开始下一个篇章的战斗!&quot;, 3);&#125; 演示： 摄像机的震动（增强打击效果）1234void Start () &#123;//对摄像机进行抖动，1，震动时间，Vector3:震动范围transform.DOShakePosition(1, new Vector3(3, 3, 0));&#125; 效果： 颜色的渐变与透明度渐变12345text = GetComponent&lt;Text&gt;();//慢慢变成红色text.DOColor(Color.red, 3);//慢慢的显示出来text.DOFade(1, 3); 显示： 3.DoTween的可视化编辑 4.DoTweend的路径编辑器 1.基本介绍：主要功能就是： a.路径点的创建和删除。 b.路径的可视化。 c.路径动画的控制。 2.Path路径动画的创建：静态创建： 在需要添加Path动画的物体上挂上 DOTweenPath 组件. a. Shift + Ctrl ： 添加路径点 b. Shift + Alt ： 删除路径点动态创建： transform.DOPath(vector3[] waypoints,float duration); a. waypoints ： 路径点 b. duration ： 动画时间 c. pathtype ： 路径类型，路径类型分为线性或者利用CatmullRom插值算法形成的曲线。(默认参数) d. pathmode ： 路径模式，主要是用于对物体三个方向上的旋转的限制。(默认参数) e. resolution ：CatmullRom算法的参数,数值越大曲线越精细,一般5足以，默认为10。(默认参数) f. gizmoColor ：辅助线的颜色,只会在动画Running时在Secene面板上可见。 （默认参数） 3.Path路径动画的属性：一般动画有的属性Path都有，几个独特的属性： a. Ease ：动画类型 b. ClosePath ：封闭路径，如果勾选此属性路径将会形成一个封闭环。 c. LocalMovement ：局部移动，如果勾选此属性将会按照局部坐标移动。 d. Orientation ：运动朝向，分为ToPath朝向路线LookAtTran朝向Tran和LookatPos朝向点. e. LookAhead ：朝向前瞻性，数值越大朝向约向靠近更前方的点。 f. Relative ：点相对，表示路径点是否与物体为相对的。 4.Path路径动画的相关方法：一般动画有的方法Path都有,几个独特的方法： a. SetOptions(bool closePath,AxisConstraint lockPos,AxisConstraint lockRota); i.是否为封闭路径 ii.路径上三个维度的位置限制，给的参数为AxisConstraint.X,那么路径在X上位置不会变化。 ii.路径上三个维度的方向限制，给的参数为AxisConstraint.X,那么路径在X上方向不会变化。 b. SetLookAt() 设置Path动画 Orientation 属性的。 c. PathLength() 返回路径长度。 d. PathGetPoint(float pathPecentage); 参数为0~1小数,返回路径上小数百分比对应的点。 e. PathGetDrawPoint(float pathPecentage);参数为返回构成路径点的个数。 注意d.e两个方法，如果返回为Vector3.zero或者null.表示路径无效、路径尚未初始化或者这不是一个路径动画.封闭路径 设置效果：]]></content>
      <categories>
        <category>Unity DoTween动画插件</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>动画插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shadowsocks原理和通过VPS自搭代理服务器]]></title>
    <url>%2F2017%2F11%2F11%2FShadowsocks%E5%8E%9F%E7%90%86%E5%92%8C%E9%80%9A%E8%BF%87VPS%E8%87%AA%E6%90%AD%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Shadowsocks是一个轻量级socks5代理插件，最初用 Python 编写,主要用于翻越GFW(中国国家防火墙),ShadowSocks支持远程DNS解析，可以防止DNS污染。所有数据流量全部经过加密，加密算法可选并支持自定义算法，隐蔽性很强， 相比于传统的VPN方式，ShadowSocks支持PAC列表，根据PAC中的规则进行智能切换，兼顾了访问速度与访问效率。 1.1Shadowsocks的翻墙原理：天朝局域网通过GFW隔离了我们与外界的交流，当然，这个隔离并非完全隔离，而是选择性的，天朝不希望你上的网站就直接阻断。每一个网络请求都是有数据特征的，不同的协议具备不同的特征，比如 HTTP/HTTPS 这类请求，会很明确地告诉 GFW 它们要请求哪个域名；再比如 TCP 请求，它只会告诉 GFW 它们要请求哪个 IP。 GFW 封锁包含多种方式，最容易操作也是最基础的方式便是域名黑白名单，在黑名单内的域名不让通过，IP 黑白名单也是这个道理。如果你有一台国外服务器不在 GFW 的黑名单内，天朝局域网的机器就可以跟这一台机器通讯。那么一个翻墙的方案就出来了：境内设备与境外机器通讯，境内想看什么网页，就告诉境外的机器，让境外机器代理抓取，然后送回来，我们要做的就是保证境内设备与境外设备通讯时不被 GFW 怀疑和窃听原理图：在我们和目标地址之间有一个代理服务器，这个VPS一定是要能访问到，并且可以访问目标网站的，所以一般VPS选择国外的。 我们首先通过SS Local和VPS进行通信，通过Socks5协议进行通信。 SS Local连接到VPS， 并对Socks5中传输的数据进行对称加密传输，传输的数据格式是SS的协议。 SS Server收到请求后，对数据解密，按照SS协议来解析数据。 SS Server根据协议内容转发请求。 SS Server获取请求结果后回传给SS Local SS Local获取结果回传给应用程序 VPN 与 Shadowsocks 的区别：VPN顾名思义，虚拟专网，你接入VPN就是接入了一个专有网络，那么你访问网络都是从这个专有网络的出口出去，好比你在家，你家路由器后面的网络设备是在同一个网络，而VPN则是让你的设备进入了另一个网络。同时你的IP地址也变成了由VPN分配的一个IP地址。通常是一个私网地址。你和VPN服务器之间的通信是否加密取决于连接VPN的具体方式/协议。 Shadowsocks的Sock5代理服务器则是把你的网络数据请求通过一条连接你和代理服务器之间的通道，由服务器转发到目的地。你没有加入任何新的网络，只是http/socks数据经过代理服务器的转发送出，并从代理服务器接收回应。你与代理服务器通信过程不会被额外处理，如果你用https，那本身就是加密的。 Shadowsocks中全局模式与PAC模式之间的区别：PAC模式就是会在你连接网站的时候读取PAC文件里的规则，来确定你访问的网站有没有被墙，如果符合，那就会使用代理服务器连接网站，而PAC列表一般都是从GFWList更新的。GFWList定期会更新被墙的网站（不过一般挺慢的）。 全局模式下，所有网站默认走代理。而PAC模式是只有被墙的才会走代理，推荐PAC模式，如果PAC模式无法访问一些网站，就换全局模式试试，一般是因为PAC更新不及时（也可能是GFWList更新不及时）导致的。 根据以上的原理，我们需要一个VPS,在这里我选择tultr的VPS,由于只有tultr，搬瓦工，香港阿里云的支付方式支持支付宝，无奈学生党只有支付宝，而tultr又较为优惠。 依次点击 Servers Deploy New Servers (那个加号). Server Location: 就选你要选的机房（日本，或者美国旧金山的网络较好） Server Type: CentOS或者Ubuntu（国内这两个的教程最多出现了错误方便查找） Server Size: 最低配就可以 其它的不用填写也可以 Deploy Now 注意：创建好服务器之后，先打开电脑控制台ping一下ip地址,当ping成功之后在进行其他的操作（我就由于日本的机房没ping就配置服务器导致配置好之后连不上，检查了半天发现那边的机房是连不了的，浪费了许多时间。 CentOS系统建立完成之后进入到server Inormation界面，单击右上角一个像显示器的图标“View Console”即可进入控制台 进入后，输入“root“，并输入服务器状态页面显示的密码即登陆成功 如果嫌密码不好记可以在这里输入”Passwd”，即可修改密码 但是以上通过view Console的方式配置服务器比较麻烦，多次配置出现错误就换了了安全终端模拟软件 安全终端模拟软件：可以远程浏览服务器系统的终端，通过SHH协议链接 常用的有两种一是putty一个是Xshell5，而在使用Xshell5的时候不知为什么就是连不上服务器。 在软件只填主机ip地址，端口号不用动，因为经过测试刚开的服务器只开通了22端口连接进入后在以下窗口输入账号密码（在server information界面都有) 而使用putty就连上了： 配置环景： pip是 python 的包管理工具。在本文中将使用 python 版本的 shadowsocks，此版本的 shadowsocks 已发布到 pip 上，因此我们需要通过 pip 命令来安装. 输入一下命令1yum install python-setuptools &amp;&amp; easy_install pip 接着会询问你是否安装，输入：1y 安装shadowsocks1pip install shadowsocks 接着，创建一个Shadowsocks配置文件,输入以下命令：1vi /etc/shadowsocks.json 然后进入文件编辑界面，按i开始编辑，输入：123456&#123;&quot;server&quot;:&quot;your_server_ip&quot;, //你的ip地址&quot;server_port&quot;:5656, //你的登录端口&quot;password&quot;:&quot;your_password&quot;, //你自己设置的一个密码，用于终端登录&quot;method&quot;:&quot;aes-256-cfb&quot;, //加密方式&#125; 编辑完成之后按esc然后打 ：wq 退出并保存文件 开通你的登录端口：1firewall-cmd --zone=public --add-port=5656/tcp --permanent 着这里可以通过站长工具网站检查站点是否开通，开启前：开启后： 启动shadowsocs1ssserver -c /etc/shadowsocks.json -d start 如果需要关闭就输入：1ssserver -c /etc/shadowsocks.json -d stop 至此就安装完成了，就可以通过github上下载的shadowsocks终端进行登录翻墙了 涉及的知识：Shadowsocks原理和搭建 : http://blog.021xt.cc/archives/98Vim入门基础: www.jianshu.com/p/bcbe916f97e1CentOS7使用firewalld打开关闭防火墙与端口: http://www.cnblogs.com/moxiaoan/p/5683743.html]]></content>
      <categories>
        <category>Shadowsocks</category>
      </categories>
      <tags>
        <tag>Shadowsocks</tag>
        <tag>VPS</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios中property的参数分析]]></title>
    <url>%2F2017%2F11%2F06%2Fproperty%E7%9A%84%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[@Property是声明属性的语法，它可以快速方便的为实例变量创建存取器，并允许我们通过点语法使用存取器,@property表示由编译器来自动实现属性的getter/setter方法，不需要你自己再手动去实现,这篇文章对@property中四组对立的参数进行了基本的分析与总结，并对控件中什么时候使用强引用，什么时候使用弱引用进行了讨论。 第一组：内存管理特性 retain assign copy strong weak第二组：读 /写特性 readwrite readonly第三组：多线程特性 nonatomic atomic第四组：方法名特性 ： setter getterassign（默认参数）：使用场景：基本数据类型(int\float)\枚举\结构体setter方法直接赋值，不进行任何retain操作，不改变引用计数，id类型也要用assign，所以一般iOS中的代理delegate属性都会用assign来标示 retain：使用场景：成员变量生成符合内存管理的set方法（release旧值，retain新值），适用于OC对象的成员变量。 copy：使用场景： NSString\NSMutableString\block生成符合内存管理的set方法（release旧值，copy新值），不过该属性会被复制一个新的副本。很多时使用copy是为了方式Mutable（可变类型）在我们不知道的情况下修改了属性值，而用copy可以生成一个不可变的副本防止被修改。 Strong：使用场景： strong :其他OC对象强引用，其存亡直接决定了所指向对象的存亡。使用该特性实例变量在赋值时，会释放旧值同时设置新值，对对象产生一个强引用，即引用计数+1。如果不存在指向一个对象的引用，并且此对象不再显示在列表中，则此对象会被从内存中释放。 weak：weak :代理\UI控件弱引用，不决定对象的存亡。属性表明了一种”非拥有关系“，既不释放旧值，也不保留新值，即引用计数不变，当指向的对象被释放时，该属性自动被设置为nil。即使一个对象被持有无数个弱引用，只要没有强引用指向它，那么还是会被清除。 readwrite（默认参数）：同时生成set、get方法的声明与实现 readonly：只生成get方法的声明与实现（不生成set的方法的声明与实现） atomic（默认参数）：原子性，性能低（一般开发OC中的APP不推荐使用，做金融等高安全的时候使用） nonatomic：非原子性，性能高（强烈推荐使用，性能高） setter：给成员变量的set方法重命名，set方法默认命名：- （void） set成员变量名（成员变量名首字母大写）：（成员变量数据类型）成员变量名 getter：给成员变量的set方法重命名，get方法默认命名：- （成员变量数据类型） 成员变量名 为什么 iOS 开发中，控件一般为 weak 而不是 strong？从storyboard或者xib上创建控件，在控件放在view上的时候，已经形成了如下的引用关系,以UIButton为例：UIViewController-&gt;UIView-&gt;subView-&gt;UIButton，UIButton已经被控件强引用了，所以拖出来的控件是弱引用 1@property(nonatomic,weak) IBOOutlet UIButton *btn; 而当自己自定义Button按钮的时候就需要对它进行强引用了： 1@property(nonatomic,strong) UIButton *btn; strong指针能够保持对象的生命，一个对象只要有strong指针指向它，那么它就不会被释放；相反的，如果一个没有一个strong指针指向它，那么它将会被自动释放。默认所有实例变量和局部变量都是Stong指针 weak型的指针变量仍然可以指向一个对象，但不属于对象的拥有者。即当对象被销毁的时候，这个weak指针也就自动指向nil（空指针）。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity UGUI界面]]></title>
    <url>%2F2017%2F10%2F02%2FUGUI%2F</url>
    <content type="text"><![CDATA[不属于3d环境中的时刻显示在屏幕上的，用于游戏的开始菜单，RPG游戏的菜单栏，侧边栏与功能栏比如背包系统，任务列表，设计用来控制移动的虚拟杆和攻击的攻击按钮 创建一个公告的文本列表 游戏内的公告板用于对玩家的提示，或者是任务的了解 1.创建一个UI的image2.只能上下拖动就要取消勾选以下按钮： 3. 在刚创建的image下创建一个text 4。为了只显示在框内要添加Scoll Rect组件 5.为了消除白板要添加Mash组件 6.添加Scrollbar滑动组件7.把Scrollbar组件添加到被滑动的Image上 最终实现的效果： 监控UI界面的按钮点击事件（点击开始按钮开始游戏） 用于游戏中场景的切换 1.按钮上的点击事件： 2.脚本代码：123456789using UnityEngine.SceneManagement;public class StartGame : MonoBehaviour &#123;public void OnClick(string sceneName)&#123;SceneManager.LoadScene(sceneName);&#125;&#125; 实现： 制作一个显示血条的UI: 血条的增减是游戏中的基本 1.添加一个slider的组件： 2.修改图片的类型: 实现： 制做一个技能 对于一个游戏角色来说，多变的技能必不可少，这里主要简单的实现了技能UI的检测，与触发 1.创建一个鼠标点击事件和检测按钮按下脚本 2.创建被技能加载的图片 3.脚本代码：12345678910111213141516171819202122232425262728293031323334353637383940using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI; //添加UIpublic class skill1 : MonoBehaviour &#123;public float timer = 0;public bool isStartTimer = false;public float coldTimer = 2;public Image Imageskill1;public KeyCode keyCode1;// Use this for initializationvoid Start () &#123;Imageskill1 = transform.Find(&quot;load&quot;).GetComponent&lt;Image&gt;(); //寻找图片下的Image组件&#125;// Update is called once per framevoid Update () &#123;if (Input.GetKeyDown(keyCode1)) //监控按钮时间&#123;isStartTimer = true;&#125;if (isStartTimer)&#123;timer += Time.deltaTime; //开始计时Imageskill1.fillAmount = (coldTimer - timer) / coldTimer; //把得到的时间的比例传递个Image组件if(timer &gt;= coldTimer)&#123;timer = 0;isStartTimer = false;Imageskill1.fillAmount = 0;&#125;&#125;&#125;public void OnClick() //监控点击事件&#123;isStartTimer = true;&#125;&#125; 4.开启监控： 最终实现： 制作一个角色的物品栏面板 游戏中的物品栏面板用于玩家对自己已获得物品的了解 1.为不同的物品栏面板添加toggel选项卡组件 2.添加Togger Group组件使选项卡只能选择一个： 3.为面板添加自动布局 4.为了防止物体图片被自动布局影响，创建一个空的中间物体 实现： 制作一个关卡选择界面(实现关卡的拖动与选择） 便于玩家选择关卡 1.点击按钮实现关卡选择界面的切换： 2.拖动与点击跟随触发代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576using System;using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.EventSystems; //实现接口所需要引用的using UnityEngine.UI;public class LevelButtonScroll : MonoBehaviour,IBeginDragHandler,IEndDragHandler &#123; //实现接口private ScrollRect scrollRect;private float[] pageArray = new float []&#123; 0, 0.5f, 1 &#125;;private float smoothing = 3; //滑动速度private float targetPosition;private bool isDragStart = false;public Toggle[] toggler; //创建跟随触发的toggle数组// Use this for initializationvoid Start () &#123;scrollRect = GetComponent&lt; ScrollRect &gt; (); //获得ScrollRect组件&#125;// Update is called once per framevoid Update () &#123;if(isDragStart ==false) //当开始拖动的时候才用这个方法赋予scrollRect值scrollRect.horizontalNormalizedPosition = Mathf.Lerp(scrollRect.horizontalNormalizedPosition, targetPosition, Time.deltaTime * smoothing);//缓慢的移动&#125;public void OnBeginDrag(PointerEventData eventDate)&#123;isDragStart = true;&#125;public void OnEndDrag(PointerEventData eventData)&#123;isDragStart = false;float posX = scrollRect.horizontalNormalizedPosition; //获取int index = 0;float offset = Mathf.Abs(pageArray[index] - posX); //初始化偏移量for(int i = 1; i &lt;pageArray.Length;i++)&#123;float offsetTemp = Mathf.Abs(pageArray[i] - posX); //拖动的位置更与不同页的位置差if (offsetTemp &lt; offset) // 比较偏移的值更接近哪个页数的值&#123;index = i;offset = offsetTemp;&#125;&#125;targetPosition = pageArray[index];//scrollRect.horizontalNormalizedPosition = pageArray[index]; //返回接近的位置toggler[index].isOn = true; //跟随触发&#125;/*************设置按钮开关的调用方法**********************/public void MoveTOPasage1( bool isOn) //当调用此方法时改变位置&#123;if (isOn)&#123;targetPosition = pageArray[0];&#125;&#125;public void MoveTOPasage2(bool isOn)&#123;if (isOn)&#123;targetPosition = pageArray[1];&#125;&#125;public void MoveTOPasage3(bool isOn)&#123;if (isOn)&#123;targetPosition = pageArray[2];&#125;&#125;&#125; 实现： 制作一个设置界面（关于自定义Toggle组件） 设置界面便于玩家对游戏进行一些调整，这里重点实现了一个自定义Toggle开关的实现 1.创建一个Toggle组件： 2.重写Toggle调用代码1234567891011121314151617181920212223using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class MyToggle : MonoBehaviour &#123;public GameObject switch1; //用于显示不同开关public GameObject switch2;private Toggle toggle;// Use this for initializationvoid Start () &#123;toggle = GetComponent&lt;Toggle&gt;(); //得到物体上的TOggle组件OnVlueChange(toggle.isOn); //初始化开关&#125;// Update is called once per framevoid Update () &#123;&#125;public void OnVlueChange(bool isOn) //当按钮被点击时调用&#123;switch1.SetActive(isOn);switch2.SetActive(!isOn);&#125;&#125; 实现：]]></content>
      <categories>
        <category>unit UGUI界面</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unity3d常用API]]></title>
    <url>%2F2017%2F09%2F25%2Funity%E5%B8%B8%E7%94%A8API%2F</url>
    <content type="text"><![CDATA[挑选了Unity引擎里一些核心API类例如 Object、GameObject、Rigidbody、Transform、Camera、Quaternion、Vector3等进行了详细的功能注解，注解内容包括API的使用方法、算法分析、边界条件、参数间的制约关系及注意事项等，特别是对很多功能相近或使用方法相似的API进行了较为详细的比较说明 函数调用顺序：Awake：最开始调用，做一些初始化工作。建议少用，此刻物体可能还没有实例化出来，会影响程序执行顺序。Start：不是很紧急的初始化，一般放在Start里面来做。仅在Update函数第一次被调用前调用。Reset：用户点击检视面板的Reset按钮或者首次添加该组件时被调用。此函数只在编辑模式下被调用。Reset最常用于在检视面板中给定一个最常用的默认值。Update：每一帧调用一次，帧间隔时间有可能改变。FixedUpdate：以相同时间间隔调用，用在力学更新效果中。执行在Update之前。LateUpdate：在Update和FixedUpdate调用之后调用。一般人物的移动放在Update中，而摄像机的跟进变化放到FixedUpdate中。确保两个独立。On开头的方法，是由其他事件触发调用的。OnDestory：物体被删除时调用。OnEnable：物体启用时被调用。OnDisable：物体被禁用时调用。OnGUI：这个函数会每帧调用好几次（每个事件一次），GUI显示函数只能在OnGUI中调用有关函数调用顺序可以参考官方的文档： time类 unity3D的time类在游戏中十分重要，几乎所有的游戏都要用到time类，使用场景有：技能的释放时间，限时关卡的限时，场景的加载时间等等。 方法：timeSinceLevelLoad :加载场景完成之后所花费的时间（场景开始，开始计时）fixedDeltaTime:每一帧所花费的时间frameCount:一共运行了多少帧Time.realtimeSinceStarup:从游戏开始到现在所运行的时间（当游戏暂停时和在后台运行时这个时间会一直增加Time.fixedTime:游戏运行的时间Time.fixeDeltaTime:游戏运行时间Time.time:游戏运行时间Time.smoothDeltaTime：平滑的时间变化Time.deltaTime:每一帧的时间间隔（变化较大）Time.timeScale:设置时间比例（可以暂停运动的物体，可以放慢动作测试性能：（开始时记录时间，结束时记录时间）1234567float time1 = Time.realtimeSinceStartup;for (int i = 0; i &lt; runCount; i++)&#123;Method1();&#125;float time2 = Time.realtimeSinceStartup;Debug.Log(time2 - time1); 会动的物体：1cube.Translate(Vector3.forward * Time.deltaTime); //每帧向前运动1m乘以没一帧时间间隔 GameObject类 所有游戏物体与场景的基类 创建物体的三种方法：一.new一个1GameObject go = new GameObject(&quot;cube&quot;); 二.根据prefab新建(相当于克隆）（游戏物体都可以） 1GameObject.Instantiate(profab); 三.创建原始的几何体 1GameObject.CreatePrimitive(PrimitiveType.cube); 给一个物体添加组件1234GameObject.CreatePrimitive(PrimitiveType.cube);GameObject go = GameObject.CreatePrimitive(PrimitiveType.Cube);go.AddComponent&lt;Rigibody&gt;() //添加刚体go.AddComponent&lt;API01EventFunction&gt;() //添加脚本 变量：activeInHerarchy: 禁用父类但是不禁用子类(判断游戏物体是否激活）activeSelf：禁用子类与父类（把一些不用的物体设置，可以节约性能；tag: 用于区别不同物体name:获取物体的名字12Debug.Log(go.name);Debug.Log(go.GetComponent&lt;Transform&gt;().name)//获取组件的名字其实获取的是物体的名字 layer:可有获取游戏所在的层scene:可以获取游戏所在的场景public Functions:AddComponent:为一个物体添加组件CompareTag:比较两个物体的标签是否一样SetActive:用于激活和禁用一个物体BroadcastMessage:广播一个消息（所有物体都能接收）(子类也会调用）12345target.BroadcastMessage(&quot;Attack&quot;,null,SendMessageOptions.DontRequireReceiver);//如果有接受者则发送，如果没有不报错void Attack() //当一个物体的脚本里拥有此方法则会被调用（子类也会调用）&#123;Debug.Log(this.gameObject + &quot;正在攻击&quot;);&#125; SendMessage:发送一个消息（不会调用子类）SendMessageUpwards: 发送消息（当前物体与父类都也会调用）Static Functions:CreatePrimitive:创建某个基本的几何体Find:根据游戏名字查找（性能; 会遍历所有游戏物体，慎用）12GameObject go =GameObject.Find(&quot;Main Camera&quot;);go.SetActive(false); FindGameObjectsWithTag:根据游戏标签查找(会查找所有的游戏物体）（效率高）12GameObject[] gos =GameObject.FindGameObjectsWithTag(&quot;MainCamera&quot;);//返回的是一个数组gos[0].SetActive(false); FindWithTag:根据游戏标签 查找（只会查找第一个）（查找到物体后一般要做判断，不为空的时候在进行操作）Object类 游戏中所有对象的基类，主要用于对对象的销毁，查找 Destroy:被销毁，但是不会立刻被回收，会将要销毁的物体集中到一起，真的不用了再销毁12Destroy(this);(一般是脚本）（可以销毁物体也可以销毁组件）Destroy(gameObject,5); //(5秒后销毁） DestroyImmediate:立刻将游戏物体从场景中删除（不建议用，有可能会造成空指针)DontDestroyOnLoad:不要销毁某个物体（一般从某个场景转到下一个场景，会销毁所有的物体）会带到下一个场景，始终存在。设置共享的游戏物体FindObjectOfType:查找某个游戏物体（根据组件类型查找游戏物体，找到第一个就返回，不管其他的）FindObjectsOfType:会查找所有符合的组件（不查找未激活，被禁用的）12Light light =FindObjectOfType&lt;Light&gt;(); //获取所有的灯light.enabled = false; Injstantizte:实例化一个对象MonoBehaviour 所有游戏脚本的基类，用于对游戏脚本进行操作 monoBehaviour中很多方法都与GameObject中的方法一致，在对MonoBehaviour进行操作就是对游戏物体进行操作GetComponent:获得一个组件12Cube cube = target.GetComponent&lt;Cube&gt;(); //类Transform t = target.GetComponent&lt;Transform&gt;(); GetComponents: 获得所有的相同组件123456Cube[] cubes = target.GetComponents&lt;Cube&gt;();cubes = target.GetComponentsInChildren&lt;Cube&gt;();foreach(Cube c in cubes)&#123;Debug.Log(c);&#125; ExecuteInEditMode: 一个特性（把此方法放在类上可以使类在编辑模式下就被调用）1234[ExecuteInEditMoe]public class PrintAwake : MonoBehaciour&#123;&#125; invoke: 调用某个方法（判断方法是否被调用，如果没有被调用，就会在2秒后被调用）123456789Invoke(&quot;Attack&quot;, 3);void Update () &#123;bool res = IsInvoking(&quot;Attack&quot;);print(res);&#125;void Attack()&#123;Debug.Log(&quot;正在攻击目标&quot;);&#125; InvokeRepeating :重复调用某个方法1InvokeRepeating(&quot;Attack&quot;, 4, 2);//第四秒开始调用第一次，之后每2秒调用一次 CancleInvoke: 取消调用某个方法（取消所有的调用）1CancelInvoke(&quot;Attack&quot;); gameObject: 可以获取游戏脚本所在的物体IsActiveAndEnabled:可以判断当前组件是否启用enabel: 可以启用与禁用某个组件（禁用的updata方法）print:输出（只能在MonoBehaviour)中使用协程 在脚本运行过程中，需要额外的执行一些其他的代码，这个时候就可以将“其他的代码”以协程的形式来运行 相当于多开了一个线程是一个能暂停执行，暂停后立即返回，直到中断指令完成后继续执行的函数。 它类似一个子线程单独出来处理一些问题，性能开销较小。 调用函数的时候不会等函数方法运行完才继续执行返回值是IEnmerator; 返回参数的时候使用yield return; 协程方法的调用StartCoroutine(method()); 利用协程实现物体改变颜色123456789StartCoroutine(ChangeColor());IEnumerator ChangeColor()&#123;print(&quot;hahaColor&quot;);cube.GetComponent&lt;MeshRenderer&gt;().material.color = Color.blue;print(&quot;hahaColor&quot;);yield return null;&#125; 利用协程实现物体颜色改变的动画效果12345678910111213141516171819202122232425262728293031void Update () &#123;if (Input.GetKeyDown(KeyCode.Space))&#123;StartCoroutine(Fade()); //协程可以任何时候开启&#125;&#125;IEnumerator Fade()&#123;for (float i = 0; i &lt;= 1; i += 0.1f)&#123;cube.GetComponent&lt;MeshRenderer&gt;().material.color = new Color(i, i, i, i);//渐变色yield return new WaitForSeconds(0.1f);&#125;&#125;//IEnumerator Fade()&#123;for ( ;;)&#123;//cube.GetComponent&lt;MeshRenderer&gt;().material.color = new Color(i, i, i, i);//渐变色Color color = cube.GetComponent&lt;MeshRenderer&gt;().material.color;Color newColor = Color.Lerp(color, Color.red,0.02f);cube.GetComponent&lt;MeshRenderer&gt;().material.color = newColor;yield return new WaitForSeconds(0.02f);if (Mathf.Abs(Color.red.g - newColor.g) &lt;= 0.01f)&#123;break;&#125;&#125;&#125; startCoroutines:开始协程StopCoroutine: 停止指定的协程StopAllCoroutines: 停止所有的协程12345678910111213public IEnumerator ie;void Update () &#123;if (Input.GetKeyDown(KeyCode.Space))&#123;ie = Fade();StartCoroutine(ie); //协程可以任何时候开启&#125;if (Input.GetKeyDown(KeyCode.E))&#123;StopCoroutine(ie);&#125;&#125; MessageOnMouseDown ：监听鼠标是否点击这个物体OnMouseDrag ：监听鼠标按下的过程中拖拽的时候OnMouseEnter : 鼠标移上去的时候（跟鼠标按不按下没有关系）OnMouseExit : 鼠标移开的时候OnmouseOver : 鼠标在物体上的时候OnMouseUp ：鼠标点击完抬起的时候OnMouseUpAsButton:鼠标按下与抬起实在同一个物体的时候（点击）12345678910111213141516171819202122232425262728void OnMouseDown()&#123;print(&quot;Down&quot;);&#125;void OnMouseUp()&#123;print(&quot;up&quot;);&#125;void OnMouseExit()&#123;print(&quot;Exit&quot;);&#125;void OnMouseDrag()&#123;print(&quot;Drag&quot;);&#125;void OnMouseEnter()&#123;print(&quot;Enter&quot;);&#125;void OnMouseOver()&#123;print(&quot;Over&quot;);&#125;void OnMouseUpAsButton()&#123;print(&quot;Button&quot;);&#125; Mathf 有关于数学公式的函数 Sttic Variables:PI:3.1415926…..Deg2Rd:把读数变为弧度Red2Deg:把弧度变为读数epsilon ：无限小的小数Infinity : 无限大的数字NegativeInfinlty : 无线大的数字Static Functions Abs:取绝对值Ceil: 向上取整（负数也可以）CeilToInt: 向上取整返回整数Clamp :夹紧（当小于min，取min,当大于max,取max)12transform.position = new Vector3(Mathf.Clamp(Time,time,1.0F,3.0),0,0) //将一物体从1移到3后停止hp = Mathf.Clamp(hp,0, 100); //限制某个数值在什么范围内 Clamp01: 把一个值限定在（0,1）之间DeltaAngle : 算出两个角度的最短的差Exp: e的多少次方ClosePowerOfTwo :取得离二得次方最近的数12print(Mathf.ClosestPowerOfTwo(2)); //取得离二得次方最近的数print(Mathf.ClosestPowerOfTwo(3)); floor: 向下取整FloorToInt：向下取整返回intMax 取得最大值12print(Mathf.Max(1, 2));print(Mathf.Max(1, 2, 5, 3, 10)); Min: 取得最小值12print(Mathf.Min(1, 2));print(Mathf.Min(1, 2, 5, 3, 10)); Pow(f,p) 取得ｐ的f次方1print(Mathf.Pow(4, 3)); //4的3次方 Sqrt : 取得参数的平方根1print(Mathf.Sqrt(3)); Lerp: 差值运算：(可以控制角色的移动，也可以控制动画）12345cube.position = new Vector3(0, 0, 0);float x = cube.position.x;//float newX = Mathf.Lerp(x, 10, Time.deltaTime); //一秒后到达位置每帧调用每帧所花的时间间隔float newX = Mathf.Lerp(x, 10, 0.1f); //每一帧都会用新组成的数进行差值运算cube.position = new Vector3(newX, 0, 0); //先快后慢 LerpAngle: 角度的差值运算MoveTowarrds : 想某个方向移动1float newX = Mathf.MoveTowards(x, 10, 0.02f); //匀速运动 PingPong: 从0到最大值来回移动（不能设置最小值）只能设置长度（当超出长度的时候就开始减小）123print(Mathf.PingPong(t,30));//print(Mathf.PingPong(t,30));cube.position = new Vector3(Mathf.PingPong(Time.time, 10), 0, 0); Input 有关于键盘鼠标等输入的函数与设置 GetKey: 监测按键按下（按着会一直返回ture)1234if(Input.GetKeyDown(&quot;left shift&quot;))&#123;print(&quot;left shfit&quot;);&#125; GetkeyDown : 监测按键按下（只有在按下时会返回ture）GetKeyUp: 监测按键抬起GetButton: 监测虚拟按键GetMouseButton: 监测鼠标的按键（0，左键1，右键2，中键）（按下的过程中会一直抬起）GetAxis: 控制运动（运动具有渐变效果）1cube.Translate(Vector3.right * Time.deltaTime * Input.GetAxis(&quot;Horizontal&quot;)); GetAxisRaw: 运动没有渐变效果（缓冲效果）GetTouch: 监测触摸Static Variablesacceleration: 监测重力gyo : 监测陀螺仪anyKeyDown: 检测任何键的按下（会一直返回ture)(鼠标，按键）1234if(Input.anyKeyDown)&#123;&#125; mousePosition: 检测鼠标在屏幕的位置1print(Input.mousePosition）; vector2 2d模式下有关向量与位置的操作 Static Variablesdown,left,right,up: 上下左右one,zero: 坐标轴为（1,1）（0,0）的向量Variablesmagnitude: 获取向量的长度normalized: 把向量单位化（把一个不管长度为多少的向量化为1）sqrMagnitude：向量长度还没有被平方根的长度（节省性能）x,y :获取x,y12345ptrint(Vector2.down);Vector2 a= new Vector2(2,2);Vecotr2 b = new Vector(3,5);print(a.magnitude);print(a.sqrMagnitude); Constructors(构造方法）vector2: 直接new一个修改位置：向量是结构体，是值类型，要整体赋值。transform.position = new Vector3(3,3,3); //不能直接修改 Vector3 pos = transform.position; pos.x = 10; transform.position = pos; Public FunctionsEquals: 判断两个向量是否相等normalized: 把自身单位化Set: 进行赋值ToString：转换为String;StaticFunctionAngle: 取得两个向量的夹角ClampMagnitude：对向量的长度进行限定Distance: 取向量之间的距离Dot: 点乘LerP: 对ｘ，ｙ进行两差值运算。LerpUnclamped :差值运算不限定最大值MoveTowards:从当前目标向目标运动123Public Vector2 a = new Vector(2,2);public Vector2 target new Vector(10,3);a = Vector2.moveTowards(a,target,Time.deltaTime). Vector3 3d模式下有关向量与位置的操作 Class: 两个向量进行叉乘运算OrthoNormalize: 让两个向量的夹角为９０度Project: 一个向量在另一个向量上的投影Reflect: 将向量反射Slerp: 求两个向量的差值（按照角度）operator - * / + ==对向量的运算（判断是否相等）Random 随机生成数，在游戏中有着广泛的应用，用于增加游戏的不确定性 Range: 返回一个随机数(不包含最大值）12print(Random.Range(4,10)）;print(Random.Range(4,10f); InitState: 设置随机数生成的种子1Random.InitState(0); ColorHSY:随机生成一个颜色value: 生成一个0到１的小数（包括０，１）State:获取一个种子rotation: 随机获取一个方向（朝向）InsideUnitCirle:在一个圆内随机生成坐标（可以用于生成敌人）(二维）1cube.position = Randon.insideUnitCircle*5; InsideUnitsphere: 在一个圆内随机生成Quaernion(四元数） 控制物体旋转 eulerAngles: 把四元数转换为欧拉角(常用）1cube.eulerAngles = new Vetor3(45,45,45); Euler:把欧拉角转换为四元数1cude.rotatiion = Quaternion.Euler(new Vector(45,45,45)); LookRotation:会使物体旋转到目标方向（望向目标）123456if (Input.GetKeyDown(&quot;left shift&quot;))&#123;Vector3 dir = enemy.position - player.position;／／dir.y = 0; 会忽略ｙ的高度player.rotation = Quaternion.LookRotation(dir);&#125; 使转动更加平滑： 12Quaternion target = Quaternion.LookRotation(dir);player.rotation = Quaternion.Slerp(player.rotation, target, Time.deltaTime); Rigidbody 刚体组件，使物体受力的作用 freezeRotation：冻结旋转position: 控制位置(比用transform块）12playerRgd.position = playerRgd.transform.position +Vector3.forward * Time.deltaTime; MovePositon: 持续的运动用着个（用差值的方式使运动更加平滑） rotation: 控制旋转（比用Transform快）AddForce: 给物体施加力1playerRgd.AddForce(Vector3.forward * force); MoveRotation: 控制持续的旋转12playerRgd.position = playerRgd.transform.position +Vector3.forward * Time.deltaTime; Cameera 摄像头，用于控制视角 main:直接获取mainCameraCamer.main 通过Camer把屏幕上的点转为射线，用于检测鼠标是否移动到物体上 ScreenPointToRay: 把屏幕坐标转换为射线鼠标移动输出在鼠标上的物体： 12345678910111213141516171819Ray ray = mainCamera.ScreenPointToRay(Input.mousePosition);RaycastHit hit;bool isCollider = Physics.Raycast(ray, out hit);if(isCollider)&#123;Debug.Log(hit.collider);&#125; 从屏幕上射出一条射线1234Ray ray = mainCamera.ScreenPointToRay(new Vector3(200,200,0));Debug.DrawRay(ray.origin, ray.direction * 10,Color.yellow); Application dataPath: 数据路径Streaming Assets: 资源文件(创建后不会被打包）identifier: 包的名字isFocused: 判断是否是焦点isMobile： 是否在移动平台isPlaying: 编辑模式下载运行会返回ture在编辑器模式下退出游戏1UnityEditor.EditorApplication.isPlaying = false; Plaatform: 可以控制在某个平台下运行identifier:标识名companyName: 公司名prodctName: 游戏名字runlnBackGround: 是否在后台运行unityVersion: 判断unity的版本OpenURL: 可以打开页面sceneManager（场景管理器） 场景管理器用于管理场景的切换与销毁，加载 Static VariablessceneCount 加载的场景数量sceneCountlnBuildSettingss 加载列表中的场合LoadScene 加载场景LoadSceneMode 加载场景有两种模式Single (单独的）：把所有的物体摧毁加载新的场景 Addditive: 不改变原来的场景下，加载新的场景12345using UnityEngine.seneManagement;if(Input.GetKeyDown(KeyCode.Space))&#123;SceneManager.LoadScene(1);&#125; LoadSceneAync 异步加载场景(h会返回一个AsynOperation的对象，利用AsyncOperation的progress对象会获得0到一的值，1代表完成，isDone,判断是否完成)GetActiveScene：获得当前场景1SceneManager.GetActiveScene().name; GetSceneByName: 用名字获取场景GetSceneByPath: 用名字来获取场景SetActiveScene: 激活某个场景，用来激活某个场景。acticeSceneChanged: 加载某个场景的时候sceneLoadded: 场景加载完成的时候触发123456789void OnActiveSceneChanged(Scene a,Scene b)&#123;print(a.name);print(b.name);&#125;void OnSceneLoaded(Scene a,LoadSceneMode)&#123;print(a.name + &quot; &quot; +mode);&#125; sceneUnloaded: 场景被销毁的时候GetSceneByBuildIndex: 获取已加载的场景的信息Quit:退出游戏CaptureScreenshot： 游戏截图]]></content>
      <categories>
        <category>unity3dAPI</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《游戏快乐设计之道》读书笔记]]></title>
    <url>%2F2017%2F09%2F24%2F%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E5%BF%AB%E4%B9%90%E4%B9%8B%E9%81%93%2F</url>
    <content type="text"><![CDATA[一款游戏为什么会变的乏味？ 游戏最大的限制是其本身的性质。它们可以锻炼我们的大脑。不能锻炼大脑的游戏很乏味。这就是井字游戏最终遭淘汰的原因—它可以锻炼大脑，但十分有限。我们不需要花太多的时间在它上面。随着我们学到更多的模式，游戏需要更加新颖才能引人注目。练习可以让一个游戏保鲜一段时间，但在很多情况下我们就会说：“我已经弄清楚了，不需要再练习这个任务了”，接着我们将目光转向其他游戏。几乎所有游戏都深受其害。它们是受限的形式系统。如果你不断玩他猛，最终总会彻底掌握它们。从这个意义上讲，游戏用完就可以丢弃，最终不可避免地会变的乏味起来。 《木筏》or《船长漂流记（Raft）》是一款生存冒险游戏，游戏中玩家可以体验鲁冰逊式的漂流体验。 《船长漂流记》采用第一人称的表现方式，玩法需要扮演被困在海洋中的主角，驾驶一个木筏子，开始冒险故事。玩家能使用的工具非常有限，只有鱼竿、鱼叉等一些小道具。玩家除了需要面对恶劣的环境，还需要收集道具、食物，满足生存需求。你的最终目标只有一个：活下来！ 我一直都挺喜欢这类具有创新的生存冒险游戏，进入游戏的体验的却使我沉迷其中，然而在玩过了2小时后却再也找不到任何的乐趣，在游玩两个小时后玩家就已经处于无敌的状态了，食物充足，道具大量，鲨鱼再也不能伤害到玩家，玩家除了扩大自己的居住所，就无所事事了，最终离开了这个游戏。也可能是当时玩的是初始版本，据说最新版本已经能够在海上的自由建造别墅是居所，在后期使其成为建造游戏，这大大增加了游戏游玩的周期。 游戏的快感是从掌握和理解中获得的，是解谜行动本身使游戏变的有意思。换句话说，在玩游戏时，学习就是兴奋剂 厌烦刚刚好相反，当一个游戏不能教给我们的时候，我们就会开始觉得它十分无聊。厌烦是大脑在寻找新的信息。这就是当我们无法体验到新模式的感觉。当一本书无法吸引你读下面的章节时，就说明它没有展现出它的魅力。到那个一本书无法吸引你读下面的章节时，就说明它没有展现出它的魅力。同样，当你感觉一首乐曲只是在不断重复或者毫无创业时，你就会觉得无聊，因为它没有激起我们对认知的挑战。 不要低估大脑想要学习的欲望。如果把一个人放在一个没有任何东西可以感知的屋子中，他很快就会觉得不开心。大脑需要刺激，它时时刻刻都在尝试学习新内容，从周围世界积累各种信息。在这方面，大脑是永不知足的。 大脑不喜欢多余的工作，当游戏无法在它所提供的谜团里展现新鲜的事物时，就会令人感到无聊。这让它在感官的剥夺与超负荷，多多的规则与混乱，寂静与喧闹之间显得进退两难。 也就是说，不一定会等到游戏结束才会出现厌烦的感觉。毕竟，大脑非常善于进行模式匹配并驱散喧闹与动静。 厌倦感会以以下的形式出现，会使本应具有的令人愉悦的学习经历消失： 玩家通过最初5分钟就弄清楚了游戏的玩法，从而觉得这样的游戏没什么意思，就像成年人玩井字游戏一样。“太简单”，这很可能是玩家对这种游戏的评价。 玩家发现游戏要达到的可能的变化需要很多东西，但是这些东西却无法令他们兴趣。 游戏中的模式变化速度太慢，这会使游戏被过早的认为没什么可玩的而被放弃“太简单-都是在重复” 玩家中的模式变化得太快了，这会使玩家因控制不了而放弃，“太难了，太快了” 玩家也许精通游戏中的所有模式，这样愉悦感就会消失殆尽“我完全打败了” 因此，一款好游戏的定义就是，“能够在玩家停止游戏之前，把应该提供的每一样东西交给玩家。 我们已经使细腻的刺激反应能力发展进化为向本能的挑战。对一些以跳跃为特色的游戏的调查表明，有“最好操作感”的游戏都有着本能的特征：当按下跳跃键时，游戏人物在空中跳跃的时间几乎和按下跳跃键的时间长短相同。“操作感不好”的游戏则违反了这个默认的规则。只要细心观察就会罚下，几十年来，好的跳跃游戏都自动遵守该规则，尽管人们甚至没有注意到该规则的存在。 自主反应本身并不会带来快乐，你已经记住了这样的反应机制，因此只有在这种心理挑战的环境下完成了自主反应的时候，大脑才会将给你快乐的感觉。比如人们并不会从打字行为本身感到多爽，而是在这个过程中想出了如何去表达，或者在打字游戏中迅速打字的时候才会感到快乐。 所有的社交行为也是令人愉悦的。人人参与的社会地位连续更替是一种认知训练，因此从本质上说也是一种游戏。环绕交往行为周围的是一种积极的感情，是一种在社会阶梯中奖某人踢下去或者自己爬上来的信号，其中最著名的是： 幸灾乐祸：当竞争对手失败时，你的一种沾沾自喜的感情，这种本质就是前面所说的将某人踢下去。 骄傲：当完成一个重要任务时对胜利感的宣泄（例如挥动拳头），这是向他人表明自己有价值的信号。 满意：指导的某人取得成功时你的感觉。这是为了种族持续发展而存在的一种明确的回馈机制。 打扮行为：一种隐私信号，通常表明一种相对的社会地位。 回报他人：这是人类社会中相当中一个相当重要的社会信号。 快乐是什么感觉呢？可以参考Csikszentmihalyi提出的“畅感”的概念。这是一直对某个任务高度集中时的状态。当你具备绝对的控制力时，恰好有一个符合你能力水平的挑战摆到了你的面前。拉扎罗将其称为“强烈的快乐”，而且，这是一种有可能将挫败感和成就感混杂在一起的状态。喜悦是无法持久的，就像在楼梯间偶遇美人的微笑一样，是转瞬即逝的。它不可能有别的方式——应为认知不是一个可延伸的过程。离那些曾经引发你喜悦的事物，在回来之后就可以重新获得喜悦，再度获得那种认知。 “底部进食”行为–理智逻辑的玩家会有意接受更弱的对手。 奖励是游戏是否成功的关键组成部分，如果没有优势的去做一件事，大脑会立即将它丢弃。 一款成功的游往往由以下元素组成 准备，在接受挑战之前，玩家会做出一些影响成功的选择。这相当于战前疗伤，障碍对手或提前练习空间感 一系列的挑战，这是基本的内容。挑战不改变规则，而是在规则之内进行操作，使各参数略有不同。每一个可能遭遇的敌人都是一个挑战。 解决问题的能力。如果所有的道具只是一把锤子，而且只能用它做一件事，那么游戏将会十分枯燥。 运用能力所需的技能。糟糕的选择会导致失败，他可以是任何种类的：遭遇战中的资源管理不善，时间控制上的失败，敏捷性上的失败，以及无法监视运动中的所有变化。 一个拥有所有这些元素的游戏，相当于按下了正确的认知按钮，从而使游戏变得有趣。没有“预备机制的游戏只能依赖于机会。没有”空间感“的游戏是平淡无奇的。没有“一系列挑战”的游戏会很快结束的，没有“多重选择”的游戏过于简单。 还有一些值得学习的经验特征： 一个可变的反馈系统。遭遇战的结果不应该完全预知，理想的状况是，熟练地完成挑战会得到更好的回报。在国际象棋中，可变的反馈是你的对手在你走棋后的反应。 控制权问题必须得到处理。高等级的玩家不能在简单的遭遇战中获得较大的利益，不然他们会进行“底部进食”，新手玩家将无法到达游戏的其他大部分地方。 失败必须要有代价。至少是一个机会成本的代价，或者更多。下一次挑战时，你就被设定从失误的地方进入游戏–无法重来一次。再一次的尝试。可以让你有不一样的准备。 角色扮演游戏的魅力在于：你可以按照自己喜欢的方式设计角色，使用任意背景，采用自己喜欢的任何挑战，但是人们总是选择扮演相同的角色，换了游戏也不变，并乐此不疲。一个玩家选择反复的玩一个他已经彻底精通的游戏，仅仅是因为他们喜欢那种强大的感觉，而这正与游戏设计原本的出发点相违背。游戏需要鼓励人改变。游戏不是为了人们满足对权力的幻想。 我从玩的第一个网游玩了一个远程的角色，当时十分痴迷于这个角色，以至于影响了我以后的游戏角色的选择，当进入一个新游戏的时候我总是趋向于选择远程的决定，并成为了一种习惯 游戏设计的终极目标: 就是制作一款挑战永无止境，技能变化多端，既有完美的难度曲线，又根据玩家的技能水平进行调整的游戏。游戏行业已经致力于改进它的外观了。每一个游戏都增加了更多的画面，更丰富的故事背景，更动人的情节，更好的音效，动听的音乐，更逼真的环境，更多样的内容，已经更多样的内容，以及更多包含于游戏中的系统设置，但是系统本身却没有多少创新。。严格来说，对游戏趣味性的最好测试就是在没有图像，音乐，声音等情况玩下去。那即使这样，游戏也很有趣的化，那么其他的一切都会把游戏美化，放大。最富创意，最多才艺的游戏设计师在获取灵感的时候不会过多地关注其他游戏，创意来自快捷思考，而不是同类模仿。 英雄联盟火的经久不衰的很大的一部原因就是他的永无止境，技能变化多端，既有完美的难度曲线，又根据玩家的技能水平进行调整的游戏，能使玩家高度集中，且能调动玩家的各种感情]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>游戏设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打砖块Demo的代码与演示]]></title>
    <url>%2F2017%2F07%2F31%2F%E6%89%93%E7%A0%96%E5%9D%97Demo%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%BC%94%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[“打砖块”Demo主要内容：创建一面墙壁，通过鼠标点击发射子弹，击中墙壁，使其坍塌，涉及的知识：砖块的批量产生，人物的移动，射击子弹的触发，主要用与Unity的入门了解。 创建一面墙砖块1234567891011121314151617public class BrickWarGame : MonoBehaviour &#123;public GameObject brick;private int columnNum = 10;private int rowNum = 5;void Start () &#123; //Instantiate（ brick ); 创建一个brick的实例对象//Instantiate(brick,new Vector3(0,10f,0),Quaternion.idntity ); 在(0,10f,0)创建一个brick的实例对象for (int rowIndey = 0; rowIndey &lt; 10; rowIndey++)&#123;for (int columnIndex = 0; columnIndex &lt; 10; columnIndex++)&#123;// （被创建的物体 ， 创建的位置（0，5的时候刚好能露出来），是否旋转）Instantiate(brick, new Vector3(columnIndex - 5,0.5f + rowIndey, 0), Quaternion.identity);&#125;&#125;&#125; 实例图： 创建一个发射停止5秒会销毁的球123456public class Ball : MonoBehaviour &#123;// Use this for initializationvoid Start () &#123;Destroy(this.gameObject, 2f);&#125; 创造一个会移动的发射者123456789101112131415161718192021public class Shooter : MonoBehaviour &#123;public GameObject shootPos;public float force = 1000;public Rigidbody ballPrefab;public float moveSpeed = 10f;// Use this for initializatio// Update is called once per framevoid Update () &#123;//Instantiate(创建变量，从哪创建，创建的状态）if (Input.GetButtonDown(&quot;Fire1&quot;) )&#123;//当转化的类型出错的时候，unity就会为空，就会报错Rigidbody ball = Instantiate(ballPrefab, shootPos.transform.position, shootPos.transform.rotation) as Rigidbody;ball.AddForce(force * shootPos.transform.forward);&#125;float h = Input.GetAxis(&quot;Horizontal&quot;) * moveSpeed * Time.deltaTime;float V = Input.GetAxis(&quot;Vertical&quot;) * moveSpeed * Time.deltaTime;transform.Translate(h, V, 0f);&#125;&#125; 实例图： 效果演示：]]></content>
      <categories>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVC&KVO的初步认识]]></title>
    <url>%2F2017%2F07%2F15%2Fkvc%26kvo%2F</url>
    <content type="text"><![CDATA[KVO/KVC 是观察者模式在 Objective-C 中的实现，以非正式协议（Category）的形式被定义在 NSObject 中。从协议的角度看，是定义了一套让开发者遵守的规范和使用的方法。在 Cocoa 的 MVC 框架中，架起 ViewController 和 Model 沟通的桥梁。 KVC概述：即:Key-value coding,它是一种使用字符串标识符，间接访问对象属性的机制使用：利用KVC进行简单赋值： 123456void test()&#123; YPPerson *person = [[YPPerson alloc] init]; [person setValue:@&quot;王五&quot; forKey:@&quot;name&quot;]; //KVC赋值 [person setValue:@&quot;19&quot; forKeyPath:@&quot;money&quot;]; //自动类型转换 NSLog(@&quot;%@-------%.2f&quot;,person.name,person.money); &#125; 利用KVC修改私有成员变量 12345void text2()&#123; YPPerson *person = [[YPPerson alloc]init]; [person setValue:@&quot;88&quot; forKeyPath:@&quot;_age&quot;]; //私有变量 NSLog(@&quot;%@&quot;,person);&#125; 利用KVC将模型转为字典 123普通的将模型转为字典：self.name =dict[@&quot;name&quot;];self.money = [dict[@&quot;money&quot;] floatValue]; //floatValue 装换为float类 12345678910111213用kVCV将模型转为字典- (instancetype)initWithDict:(NSDictionary *)dict&#123; if (self = [super init]) &#123; [self setValuesForKeysWithDictionary:dict]； ／／优点：一行代码就把所有的模型转为了字典&#125; 使用场景：简单的字典转模型 开发中不建议使用setValuesForKeyWithDictionary: 1.字典中的KEY必须在模型的属性中找到 2.如果模型中带有模型就不好用 取出所有模型的属性值 123456789YPPerson *person1 = [[YPPerson alloc ]init]; person1.name = @&quot;zhangsan&quot;; person1.money = 12.99; person2.name = @&quot;wangwu&quot; person2.money = 13.45; NSArray allPersons = @[person1,person2]; NSArray allPersonName = [allPersons valueForKey:@&quot;naem&quot;]; NSLog(@&quot;%@&quot;,allPersonName); KVO概述：即:Key-value Observing,当指定的对象的属性被修改了，允许对象接受到通知的机制。每次指定的被观察对象的属性被修改的时候，KVO都会自动的去通知相应的观察者 允许对象观察另一个对象的属性。该属性值改变时，会通知观察对象, 如何监听：12345-（void)viewDidLoad]; [super viewDidLoad]; YPPerson *person = [[YPPerson alloc] init]; person.name = @&quot;zs&quot;; 作用：给对象绑定一个监听器（观察者）Oberver : 观察者 KeyPath :要监听的属性 Options : 选项（方便在方法中拿到属性值） 1234[Person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObserveringOptionNew | NSKeyValueObservingOptionOld context:nil];person.naem = @&quot;ls&quot;;person.name = @&quot;ww&quot;;//移除监听 当监听的属性值发改变是就调用这个方法keyPath 要改变的属性 Object 要改变的属性的对象 chang 改变的内容 context 上下文 123-（void)observeValueForKeyPath:(NSString *)KeyPath ofObject:(id)Object change:(NSDictionary&lt;NSString *,id&gt; *)chang context&#123; NSLog(@&quot;%@---------%@---------%@&quot;, keyPath, object, change);&#125; 会打印出： new = ww; old = ls;]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初次见面]]></title>
    <url>%2F2017%2F06%2F17%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[密码 1fb7a865fb6b4e7c2b0840c9e7038d6d066700f38c084a8f3a404f2c660f38b36bb8b3cbfaadda6c54749b7c915ae3969cecae8bb0b106d65ab233957bc5fb35582907eae6021c156f01b79e05a9f56495fe6bec3a5f64cf69b01f0d444d959cfff232c5570eee95ac9f14dd5b403d9652d83489c4129c8e57e93a80ae2f10307299f95ffbed4988d4c01eb95c9820fddf0cb1c90f625c6a6b7b29d8cdea85bfdd8b1581e74fe3fc182a060128375672c48b2b356a28e8180144098b4c0a5c8a25cb8ba564961ebcc89656a7f82fbb3c9eaa50d5156e4a916876a9084984a889745f2012805a541d4b5c4e7ba4cbe839ca3e69a7f29ea82eac0004aeb0f8bf483e4496bc600ceba1ce4f873c45f052b8082048d2d5061ef3c371f7665757a2ed8eeef0dfd1449fdc1b8ba54c6f317341c734e3eb49e0670bd4a97d919ba16462]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
</search>
